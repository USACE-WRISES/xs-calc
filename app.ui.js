// app.ui.js
// All UI wiring, event handlers, rendering, and app orchestration
// This file was generated by extracting the inline <script> from index.html.

/* ===================== n CATALOG (complete) ===================== */
const N_CATALOG = [
  {id:'mc-clean-straight', grp:'Main Channels', label:'Clean: straight; full; no rifts or deep pools', n:{min:0.025,typ:0.030,max:0.033}},
  {id:'mc-more-stones-weeds', grp:'Main Channels', label:'Same as above: more stones & weeds', n:{min:0.030,typ:0.035,max:0.040}},
  {id:'mc-clean-winding', grp:'Main Channels', label:'Clean: winding; some pools & shoals', n:{min:0.033,typ:0.040,max:0.045}},
  {id:'mc-winding-some-weeds-stones', grp:'Main Channels', label:'Winding: some weeds & stones', n:{min:0.035,typ:0.045,max:0.050}},
  {id:'mc-lower-stage-ineffective', grp:'Main Channels', label:'Lower stages: more ineffective slopes/sections', n:{min:0.040,typ:0.048,max:0.055}},
  {id:'mc-more-stones', grp:'Main Channels', label:'Same as “lower stages”: more stones', n:{min:0.045,typ:0.050,max:0.060}},
  {id:'mc-sluggish-weedy', grp:'Main Channels', label:'Sluggish; weedy; deep pools', n:{min:0.050,typ:0.070,max:0.080}},
  {id:'mc-very-weedy-or-timber', grp:'Main Channels', label:'Very weedy; deep pools; or floodways with timber/brush', n:{min:0.070,typ:0.100,max:0.150}},
  {id:'fp-pasture-short', grp:'Floodplains', label:'Pasture (no brush): short grass', n:{min:0.025,typ:0.030,max:0.035}},
  {id:'fp-pasture-high', grp:'Floodplains', label:'Pasture (no brush): high grass', n:{min:0.030,typ:0.035,max:0.050}},
  {id:'fp-cultivated-none', grp:'Floodplains', label:'Cultivated: no crop', n:{min:0.020,typ:0.030,max:0.040}},
  {id:'fp-cultivated-row', grp:'Floodplains', label:'Cultivated: mature row crops', n:{min:0.025,typ:0.035,max:0.045}},
  {id:'fp-cultivated-field', grp:'Floodplains', label:'Cultivated: mature field crops', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'fp-brush-scattered', grp:'Floodplains', label:'Brush: scattered; heavy weeds', n:{min:0.035,typ:0.050,max:0.070}},
  {id:'fp-brush-light-winter', grp:'Floodplains', label:'Brush: light brush & trees (winter)', n:{min:0.035,typ:0.050,max:0.060}},
  {id:'fp-brush-light-summer', grp:'Floodplains', label:'Brush: light brush & trees (summer)', n:{min:0.040,typ:0.060,max:0.080}},
  {id:'fp-brush-med-dense-winter', grp:'Floodplains', label:'Brush: medium–dense (winter)', n:{min:0.045,typ:0.070,max:0.110}},
  {id:'fp-brush-med-dense-summer', grp:'Floodplains', label:'Brush: medium–dense (summer)', n:{min:0.070,typ:0.100,max:0.160}},
  {id:'fp-trees-cleared-stumps', grp:'Floodplains', label:'Trees: cleared land; stumps; no sprouts', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'fp-trees-heavy-sprouts', grp:'Floodplains', label:'Trees: heavy sprouts', n:{min:0.050,typ:0.060,max:0.080}},
  {id:'fp-trees-heavy-stand', grp:'Floodplains', label:'Trees: heavy stand; few down trees; little undergrowth; flow below branches', n:{min:0.080,typ:0.100,max:0.120}},
  {id:'fp-trees-flow-into-branches', grp:'Floodplains', label:'Trees: as above—flow into branches', n:{min:0.100,typ:0.120,max:0.160}},
  {id:'fp-dense-willows-summer', grp:'Floodplains', label:'Dense willows (summer; straight)', n:{min:0.110,typ:0.150,max:0.200}},
  {id:'ms-gravel-cobbles', grp:'Mountain Streams', label:'Bottom: gravels; cobbles; few boulders', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'ms-cobbles-large-boulders', grp:'Mountain Streams', label:'Bottom: cobbles with large boulders', n:{min:0.040,typ:0.050,max:0.070}},
  {id:'ln-conc-trowel', grp:'Lined or Constructed Channels', label:'Concrete: trowel finish', n:{min:0.011,typ:0.013,max:0.015}},
  {id:'ln-conc-float', grp:'Lined or Constructed Channels', label:'Concrete: float finish', n:{min:0.013,typ:0.015,max:0.016}},
  {id:'ln-conc-gravel-bottom', grp:'Lined or Constructed Channels', label:'Concrete: finished; gravel bottom', n:{min:0.015,typ:0.017,max:0.020}},
  {id:'ln-conc-unfinished', grp:'Lined or Constructed Channels', label:'Concrete: unfinished', n:{min:0.014,typ:0.017,max:0.020}},
  {id:'ln-conc-gunite-good', grp:'Lined or Constructed Channels', label:'Concrete: gunite; good section', n:{min:0.016,typ:0.019,max:0.023}},
  {id:'ln-conc-gunite-wavy', grp:'Lined or Constructed Channels', label:'Concrete: gunite; wavy section', n:{min:0.018,typ:0.022,max:0.025}},
  {id:'ln-conc-good-rock', grp:'Lined or Constructed Channels', label:'Concrete: on good excavated rock', n:{min:0.017,typ:0.020,max:null}},
  {id:'ln-conc-irreg-rock', grp:'Lined or Constructed Channels', label:'Concrete: on irregular excavated rock', n:{min:0.022,typ:0.027,max:null}},
  {id:'ln-conc-bottom-dressed-stone', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—dressed stone in mortar', n:{min:0.015,typ:0.017,max:0.020}},
  {id:'ln-conc-bottom-rand-stone', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—random stone in mortar', n:{min:0.017,typ:0.020,max:0.024}},
  {id:'ln-conc-bottom-rubble-plaster', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—cement rubble masonry, plastered', n:{min:0.016,typ:0.020,max:0.024}},
  {id:'ln-conc-bottom-rubble', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—cement rubble masonry', n:{min:0.020,typ:0.025,max:0.030}},
  {id:'ln-conc-bottom-riprap', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—dry rubble or riprap', n:{min:0.020,typ:0.030,max:0.035}},
  {id:'ln-gravel-bottom-formed-conc', grp:'Lined or Constructed Channels', label:'Gravel bottom: sides—formed concrete', n:{min:0.017,typ:0.020,max:0.025}},
  {id:'ln-gravel-bottom-rand-stone', grp:'Lined or Constructed Channels', label:'Gravel bottom: sides—random stone in mortar', n:{min:0.020,typ:0.023,max:0.026}},
  {id:'ln-gravel-bottom-riprap', grp:'Lined or Constructed Channels', label:'Gravel bottom: sides—dry rubble or riprap', n:{min:0.023,typ:0.033,max:0.036}},
  {id:'ln-brick-glazed', grp:'Lined or Constructed Channels', label:'Brick: glazed', n:{min:0.011,typ:0.013,max:0.015}},
  {id:'ln-brick-mortar', grp:'Lined or Constructed Channels', label:'Brick: in cement mortar', n:{min:0.012,typ:0.015,max:0.018}},
  {id:'ln-metal-smooth', grp:'Lined or Constructed Channels', label:'Metal: smooth steel surfaces', n:{min:0.011,typ:0.012,max:0.014}},
  {id:'ln-metal-corrugated', grp:'Lined or Constructed Channels', label:'Metal: corrugated', n:{min:0.021,typ:0.025,max:0.030}},
  {id:'ln-asphalt-smooth', grp:'Lined or Constructed Channels', label:'Asphalt: smooth', n:{min:0.013,typ:0.013,max:null}},
  {id:'ln-asphalt-rough', grp:'Lined or Constructed Channels', label:'Asphalt: rough', n:{min:0.016,typ:0.016,max:null}},
  {id:'ln-vegetal-lining', grp:'Lined or Constructed Channels', label:'Vegetal lining', n:{min:0.030,typ:0.030,max:0.500}},
  {id:'ex-earth-straight-clean-new', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—clean; recently completed', n:{min:0.016,typ:0.018,max:0.020}},
  {id:'ex-earth-straight-weathered', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—clean; after weathering', n:{min:0.018,typ:0.022,max:0.025}},
  {id:'ex-earth-straight-gravel', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—gravel; uniform; clean', n:{min:0.022,typ:0.025,max:0.030}},
  {id:'ex-earth-straight-short-grass', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—with short grass; few weeds', n:{min:0.022,typ:0.027,max:0.033}},
  {id:'ex-earth-winding-none', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—no vegetation', n:{min:0.023,typ:0.025,max:0.030}},
  {id:'ex-earth-winding-grass', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—grass; some weeds', n:{min:0.025,typ:0.030,max:0.033}},
  {id:'ex-earth-winding-dense-weeds', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—dense weeds or aquatic plants (deep)', n:{min:0.030,typ:0.035,max:0.040}},
  {id:'ex-earth-winding-rubble-side', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—earth bottom; rubble sides', n:{min:0.028,typ:0.030,max:0.035}},
  {id:'ex-earth-winding-stony-weedy', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—stony bottom; weedy banks', n:{min:0.025,typ:0.035,max:0.040}},
  {id:'ex-earth-winding-cobble-clean', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—cobble bottom; clean sides', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'ex-dragline-none', grp:'Excavated or Dredged Channels', label:'Dragline‑excavated / dredged—no vegetation', n:{min:0.025,typ:0.028,max:0.033}},
  {id:'ex-dragline-light-brush', grp:'Excavated or Dredged Channels', label:'Dragline‑excavated / dredged—light brush on banks', n:{min:0.035,typ:0.050,max:0.060}},
  {id:'ex-rock-smooth', grp:'Excavated or Dredged Channels', label:'Rock cuts: smooth & uniform', n:{min:0.025,typ:0.035,max:0.040}},
  {id:'ex-rock-jagged', grp:'Excavated or Dredged Channels', label:'Rock cuts: jagged & irregular', n:{min:0.035,typ:0.040,max:0.050}},
  {id:'ex-not-maintained-clean-bottom', grp:'Excavated or Dredged Channels', label:'Not maintained: clean bottom; brush on sides', n:{min:0.040,typ:0.050,max:0.080}},
  {id:'ex-not-maintained-high-stage', grp:'Excavated or Dredged Channels', label:'Not maintained: as above—highest stage', n:{min:0.045,typ:0.070,max:0.110}},
  {id:'ex-not-maintained-dense-weeds', grp:'Excavated or Dredged Channels', label:'Not maintained: dense weeds—height ≈ flow depth', n:{min:0.050,typ:0.080,max:0.120}},
  {id:'ex-not-maintained-dense-brush', grp:'Excavated or Dredged Channels', label:'Not maintained: dense brush—high stage', n:{min:0.080,typ:0.100,max:0.140}},
];

/* ===================== XS TABLE & UI ===================== */
const tableBody = document.querySelector('#xsTable tbody');

function createRowElement(station='', elevation='', stageTag='', nVal=''){
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td class="cell-id"></td>
    <td class="cell-station"><input type="text" inputmode="decimal" class="station" value="${station}"></td>
    <td class="cell-elev"><input type="text" inputmode="decimal" class="elevation" value="${elevation}"></td>
    <td class="cell-stage">
      <select class="stagetag" title="Stage tag (LB/RB)">
        <option value=""></option>
        <option value="LB">LB</option>
        <option value="RB">RB</option>
      </select>
    </td>
    <td class="cell-n"><input type="text" inputmode="decimal" class="nval" value="${nVal}"></td>
  `;
  tr.querySelector('.stagetag').value = stageTag;
  return tr;
}

function addRow(station='',elevation='',stageTag='', nVal='', beforeRow=null){
  const tr = createRowElement(station,elevation,stageTag,nVal);
  if(beforeRow) tableBody.insertBefore(tr,beforeRow);
  else tableBody.appendChild(tr);
  renumberIDs();
  return tr;
}
function renumberIDs(){
  [...tableBody.querySelectorAll('tr')].forEach((r,i)=>{
    const id = r.querySelector('.cell-id');
    if(id) id.textContent = (i+1);
  });
}
function isLastRow(tr){
  const rows=[...tableBody.querySelectorAll('tr')];
  return rows.length && rows[rows.length-1]===tr;
}
function ensureTrailingBlankRow(){
  const rows=[...tableBody.querySelectorAll('tr')];
  if(!rows.length){ addRow('','','',''); return; }
  const last=rows[rows.length-1];
  const s=last.querySelector('.station')?.value??'';
  const e=last.querySelector('.elevation')?.value??'';
  if(s!==''||e!=='') addRow('','','','');
}
function getRows(){ return [...tableBody.querySelectorAll('tr')]; }
function rowIndexOf(tr){ return getRows().indexOf(tr); }

/* Read rows (including stage and n) */
function getPointsWithStagesRaw(){
  const pts=[];
  getRows().forEach(r=>{
    const sx=r.querySelector('.station').value, ex=r.querySelector('.elevation').value;
    const nx=r.querySelector('.nval')?.value ?? '';
    const x=parseFloat(sx), z=parseFloat(ex);
    const tag=(r.querySelector('.stagetag')?.value)||'';
    const n=(nx.trim()===''? NaN : parseFloat(nx));
    if(Number.isFinite(x)&&Number.isFinite(z)) pts.push({x,z,tag, n: Number.isFinite(n)? n : NaN});
  });
  return pts;
}

/* Validate stage uniqueness */
function enforceUniqueStageTag(sel){
  const v=sel.value;
  if(v==='LB'||v==='RB'){
    for(const s of tableBody.querySelectorAll('.stagetag')) if(s!==sel && s.value===v) s.value='';
  }
}

/* Sorting preserves stage/n */
function sortTable(){
  const rows=getPointsWithStagesRaw().slice().sort((a,b)=>a.x-b.x);
  tableBody.innerHTML='';
  for(const p of rows) addRow(p.x,p.z, p.tag||'', Number.isFinite(p.n)?p.n:'');
  ensureTrailingBlankRow();
  clearCellSelection();
  compute();
}

/* ======= Selection model ======= */
let selectedCells=new Set();
let suppressNextClick=false;
let isDragging=false;
let dragMode=null; // 'rows' | 'cells'

function isCellVisible(td){
  if(!td) return false;
  const cs = window.getComputedStyle(td);
  return cs.display !== 'none' && cs.visibility !== 'hidden';
}
function isEditableCell(td){
  return !!td && (td.classList.contains('cell-station') || td.classList.contains('cell-elev') || td.classList.contains('cell-n')) && isCellVisible(td);
}
function editableCellsInRow(tr){
  const tds = [
    tr.querySelector('td.cell-station'),
    tr.querySelector('td.cell-elev'),
    tr.querySelector('td.cell-n')
  ].filter(isEditableCell);
  return tds;
}
function cellColIndex(td){
  if(!td) return -1;
  const tr = td.closest('tr');
  if(!tr) return -1;
  const cols = editableCellsInRow(tr);
  return cols.indexOf(td);
}
function getCellByRowCol(rowIdx, colIdx){
  const rows = getRows();
  if(rowIdx < 0 || rowIdx >= rows.length) return null;
  const cols = editableCellsInRow(rows[rowIdx]);
  if(colIdx < 0 || colIdx >= cols.length) return null;
  return cols[colIdx];
}
function clearCellSelection(){
  stopEditingActiveInput();
  selectedCells.forEach(td=>td.classList.remove('cell-selected'));
  selectedCells.clear();
}
function addCellToSelection(td){
  if(!td) return;
  if(!(td.classList.contains('cell-station')||td.classList.contains('cell-elev')||td.classList.contains('cell-n'))) return;
  if(!selectedCells.has(td)){
    selectedCells.add(td);
    td.classList.add('cell-selected');
  }
}
function addRowCellsToSelection(tr){
  addCellToSelection(tr.querySelector('td.cell-station'));
  addCellToSelection(tr.querySelector('td.cell-elev'));
  addCellToSelection(tr.querySelector('td.cell-n'));
}
function firstSelectedRow(){
  if(!selectedCells.size) return null;
  const rows=getRows();
  let min=Infinity,row=null;
  selectedCells.forEach(td=>{
    const r=td.closest('tr');
    const idx=rows.indexOf(r);
    if(idx>=0 && idx<min){min=idx;row=r;}
  });
  return row;
}
function firstSelectedCell(){
  if(!selectedCells.size) return null;
  const rows = getRows();
  const candidates = [...selectedCells].filter(isEditableCell).map(td=>{
    const r = td.closest('tr');
    const rIdx = rows.indexOf(r);
    const cIdx = cellColIndex(td);
    return {td, rIdx, cIdx};
  }).filter(o=>o.rIdx>=0 && o.cIdx>=0);
  if(!candidates.length){
    const r = firstSelectedRow();
    if(!r) return null;
    const cols = editableCellsInRow(r);
    return cols[0] || null;
  }
  candidates.sort((a,b)=> (a.rIdx - b.rIdx) || (a.cIdx - b.cIdx));
  return candidates[0].td;
}
function singleSelectedCell(){
  if(selectedCells.size !== 1) return null;
  const td = [...selectedCells][0];
  return isEditableCell(td) ? td : null;
}
function selectSingleCell(td){
  if(!td) return;
  clearCellSelection();
  addCellToSelection(td);
}

function getActiveEditingInput(){
  const el = document.activeElement;
  if(el && el.tagName === 'INPUT' && el.closest('#xsTable')) return el;
  return null;
}
function stopEditingActiveInput(){
  const active = getActiveEditingInput();
  if(active) active.blur();
}

// Ensure the grid has focus so document-level key handlers work
function focusGrid(){
  const t=document.getElementById('xsTable');
  if(t && typeof t.focus==='function'){
    try{ t.focus({preventScroll:true}); }catch(_){ t.focus(); }
  }
}

function neighborCell(baseTd, dir){
  if(!isEditableCell(baseTd)) return null;
  const rIdx = rowIndexOf(baseTd.closest('tr'));
  const cIdx = cellColIndex(baseTd);
  if(rIdx < 0 || cIdx < 0) return null;
  let nr = rIdx, nc = cIdx;
  if(dir==='up'){ nr = rIdx-1; }
  else if(dir==='down'){ nr = rIdx+1; }
  else if(dir==='left'){ nc = cIdx-1; }
  else if(dir==='right'){ nc = cIdx+1; }
  if(dir==='down'){ ensureTrailingBlankRow(); }
  return getCellByRowCol(nr, nc) || null;
}

function isPrintableNumeric(e){
  if(e.ctrlKey || e.metaKey || e.altKey) return false;
  if(e.key.length !== 1) return false;
  return /[0-9eE\.\-\+]/.test(e.key);
}

function startEditingWithChar(ch){
  const td = singleSelectedCell();
  if(!td) return;
  const inp = td.querySelector('input'); if(!inp) return;
  inp.focus();
  const cur = String(inp.value ?? '');
  const next = cur + ch;
  inp.value = next;
  try{ const L = next.length; inp.setSelectionRange(L, L); }catch(_){}
  inp.dispatchEvent(new Event('input', {bubbles:true}));
}
function startEditingWithBackspace(){
  const td = singleSelectedCell();
  if(!td) return;
  const inp = td.querySelector('input'); if(!inp) return;
  inp.focus();
  let cur = String(inp.value ?? '');
  if(cur.length > 0) cur = cur.slice(0, -1);
  inp.value = cur;
  try{ const L = cur.length; inp.setSelectionRange(L, L); }catch(_){}
  inp.dispatchEvent(new Event('input', {bubbles:true}));
}

/* Drag/click selection */
tableBody.addEventListener('mousedown',(e)=>{
  stopEditingActiveInput();
  const td=e.target.closest('td');
  if(!td) return;
  if(td.classList.contains('cell-id')){
    e.preventDefault();
    if(!(e.ctrlKey||e.metaKey||e.shiftKey)) clearCellSelection();
    addRowCellsToSelection(td.closest('tr'));
    focusGrid();
    isDragging=true; dragMode='rows'; suppressNextClick=true; return;
  }
  if(isEditableCell(td)){
    e.preventDefault();
    if(!(e.ctrlKey||e.metaKey||e.shiftKey)) clearCellSelection();
    addCellToSelection(td);
    focusGrid();
    isDragging=true; dragMode='cells'; suppressNextClick=true; return;
  }
});
tableBody.addEventListener('mousemove',(e)=>{
  if(!isDragging) return;
  const td=e.target.closest('td'); if(!td) return;
  if(dragMode==='rows'){
    const tr=td.closest('tr'); if(tr) addRowCellsToSelection(tr);
  }else if(dragMode==='cells'){
    if(isEditableCell(td)) addCellToSelection(td);
  }
});
document.addEventListener('mouseup',()=>{
  if(isDragging){ isDragging=false; dragMode=null; suppressNextClick=true; }
});
tableBody.addEventListener('click',(e)=>{
  if(suppressNextClick){ suppressNextClick=false; return; }
  const td=e.target.closest('td'); if(!td) return;
  stopEditingActiveInput();
  if(td.classList.contains('cell-id')){
    clearCellSelection(); addRowCellsToSelection(td.closest('tr')); focusGrid(); return;
  }
  if(isEditableCell(td)){
    clearCellSelection(); addCellToSelection(td); focusGrid(); return;
  }
});
tableBody.addEventListener('dblclick',(e)=>{
  const td=e.target.closest('td'); if(!td) return;
  if(isEditableCell(td)){ selectSingleCell(td); }
  if(td.querySelector('input')){
    const inp=td.querySelector('input'); inp.focus();
    try{ const L=String(inp.value).length; inp.setSelectionRange(L,L);}catch(_){}
  }
});
tableBody.addEventListener('focusin',(e)=>{
  const td = e.target.closest('td');
  if(isEditableCell(td)){
    if(!(selectedCells.size===1 && selectedCells.has(td))){
      clearCellSelection(); addCellToSelection(td);
    }
  }
});

/* FIX: Enter while editing should blur & keep selection */
tableBody.addEventListener('keydown',(e)=>{
  if(e.key==='Enter' && e.target && e.target.tagName==='INPUT'){
    e.preventDefault(); e.stopPropagation();
    const td = e.target.closest('td');
    if(isEditableCell(td)){
      if(!(selectedCells.size===1 && selectedCells.has(td))){ selectSingleCell(td); }
    }
    e.target.blur();
  }
});

/* Delete/clear helpers */
function clearSelectedCells(){
  if(selectedCells.size===0) return;
  selectedCells.forEach(td=>{
    const inp=td.querySelector('input');
    if(inp) inp.value='';
  });
  ensureTrailingBlankRow();
  compute();
}
function deleteRowsWithSelectedCells(){
  const sel=[...tableBody.querySelectorAll('td.cell-selected')];
  if(!sel.length) return;
  const del=new Set(sel.map(td=>td.closest('tr')));
  del.forEach(r=>r.remove());
  renumberIDs(); ensureTrailingBlankRow(); clearCellSelection(); compute();
}

/* Inputs -> compute */
tableBody.addEventListener('change',(e)=>{
  const t=e.target;
  if(t && (t.classList.contains('stagetag') || t.classList.contains('nval') || t.classList.contains('station') || t.classList.contains('elevation'))){
    if(t.classList.contains('stagetag')) enforceUniqueStageTag(t);
    compute();
  }
});
tableBody.addEventListener('input',(e)=>{
  const t=e.target;
  if(t && (t.classList.contains('station')||t.classList.contains('elevation')||t.classList.contains('nval'))){
    const tr=t.closest('tr');
    if(isLastRow(tr)){
      const s=tr.querySelector('.station').value, z=tr.querySelector('.elevation').value;
      if(s!==''||z!=='') ensureTrailingBlankRow();
    }
    compute();
  }
});
tableBody.addEventListener('keyup',(e)=>{
  const t=e.target;
  if(t && (t.classList.contains('nval')||t.classList.contains('station')||t.classList.contains('elevation'))) compute();
});

/* Keyboard (global) */
document.addEventListener('keydown',(e)=>{
  if (e.defaultPrevented) return;

  const activeInput = getActiveEditingInput();

  if(e.key === 'Delete' && !activeInput && selectedCells.size>0){
    e.preventDefault();
    clearSelectedCells();
    return;
  }

  if(activeInput){ return; }

  const dirMap = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right' };
  if(dirMap[e.key]){
    if(selectedCells.size>0){
      e.preventDefault();
      const base = firstSelectedCell();
      if(base){
        const next = neighborCell(base, dirMap[e.key]);
        if(next){ selectSingleCell(next); }
      }
    }
    return;
  }

  if(e.key === 'Enter'){
    if(selectedCells.size>0){
      e.preventDefault();
      const base = firstSelectedCell();
      if(base){
        ensureTrailingBlankRow();
        const next = neighborCell(base, 'down') || base;
        selectSingleCell(next);
      }
    }
    return;
  }

  if(e.key === 'Backspace'){
    if(selectedCells.size===1 && isEditableCell([...selectedCells][0])){
      e.preventDefault();
      startEditingWithBackspace();
    }
    return;
  }

  if(selectedCells.size===1 && isEditableCell([...selectedCells][0]) && isPrintableNumeric(e)){
    e.preventDefault();
    startEditingWithChar(e.key);
    return;
  }
});

document.addEventListener('mousedown',(e)=>{
  const inCells=e.target.closest('#xsTable td.cell-id, #xsTable td.cell-station, #xsTable td.cell-elev, #xsTable td.cell-n');
  const onToolbar=e.target.closest('.actions')||e.target.closest('.actions-xs');
  if(!inCells && !onToolbar){ clearCellSelection(); }
});

/* Action buttons */
function flashButton(btn){
  if (!btn || !btn.classList) return;
  btn.classList.add('clicked');
  setTimeout(() => {
    try { btn.classList.remove('clicked'); } catch (_) {}
  }, 160);
}

document.getElementById('insertRow').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  if(selectedCells.size===0) return;
  const target=firstSelectedRow();
  if(target){
    addRow('','','','',target);
    ensureTrailingBlankRow();
    clearCellSelection();
    compute();
  }
});
document.getElementById('deleteSelected').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  if(selectedCells.size===0) return;
  deleteRowsWithSelectedCells();
});
document.getElementById('sortBtn').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  sortTable();
});
document.getElementById('resetExample').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  resetExample();
});

/* Controls that trigger recompute */
['units','slope','depth','discharge','nLOB','nMC','nROB'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener(id==='units'?'change':'input', compute);
});
['N_LOB','N_CHAN','N_ROB'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener('change', ()=>{
    updateSliceOptionStates();
    compute();
  });
});
['pmOff','pmXS','pmSlices'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener('change', compute);
});

/* Slice selects */
function fillSliceSelect(sel,def=1){
  sel.innerHTML='';
  for(let i=1;i<=45;i++){
    const o=document.createElement('option');
    o.value=String(i); o.textContent=String(i);
    sel.appendChild(o);
  }
  sel.value=String(def);
}
function updateSliceOptionStates(){
  const sLOB=document.getElementById('N_LOB');
  const sCH =document.getElementById('N_CHAN');
  const sROB=document.getElementById('N_ROB');
  let changed=true, guard=0;
  while(changed && guard<6){
    guard++; changed=false;
    const vLOB=parseInt(sLOB.value||'1',10);
    const vCH =parseInt(sCH.value ||'1',10);
    const vROB=parseInt(sROB.value||'1',10);
    function capOptions(sel,cur,others){
      const max=Math.max(1,45-others);
      [...sel.options].forEach(o=>{
        const v=parseInt(o.value,10);
        o.disabled=(v>max);
        o.style.color=o.disabled?'#aaa':'';
      });
      if(cur>max){ sel.value=String(max); changed=true; }
    }
    capOptions(sLOB, vLOB, vCH+vROB);
    capOptions(sCH, vCH, vLOB+vROB);
    capOptions(sROB, vROB, vLOB+vCH);
  }
}

/* Harmonize widths of some buttons */
function harmonizeButtons(){
  const btns=[document.getElementById('resetExample'), document.getElementById('sortBtn'), document.getElementById('deleteSelected')].filter(Boolean);
  if(!btns.length) return;
  btns.forEach(b=>b.style.width='auto');
  const max=Math.max(...btns.map(b=>b.getBoundingClientRect().width));
  btns.forEach(b=>b.style.width=Math.ceil(max)+'px');
}
window.addEventListener('load', harmonizeButtons);
window.addEventListener('resize', harmonizeButtons);

/* HVn toggle UI */
const hvnToggle=document.getElementById('hvnToggle');
hvnToggle.addEventListener('change', ()=> updateHVnUI(hvnToggle.checked));
function updateHVnUI(on){
  document.body.classList.toggle('hvn-on', on);
  const inputs=['nLOB','nMC','nROB'].map(id=>document.getElementById(id));
  inputs.forEach(inp=>{
    inp.disabled=on;
    inp.title = on ? 'Disabled when Horizontal Variation of n is ON' : '';
  });
  const msgEl=document.getElementById('messages');
  if(on){
    msgEl.textContent='HVn is ON: LOB/Channel/ROB n inputs and n‑picker won’t affect results. Edit n in the Cross‑Section table.';
  }else{
    msgEl.textContent='';
  }
  compute();
}

/* Specify Discharge UI */
const specifyQEl = document.getElementById('specifyQ');
specifyQEl.addEventListener('change', ()=> updateQModeUI(specifyQEl.checked));
function updateQModeUI(on){
  const depthEl = document.getElementById('depth');
  const qEl = document.getElementById('discharge');
  if(on){
    depthEl.disabled = true; depthEl.title = 'Disabled when Specify Discharge is ON';
    qEl.disabled = false; qEl.title = '';
  }else{
    depthEl.disabled = false; depthEl.title = '';
    qEl.disabled = true; qEl.title = 'Disabled when Specify Discharge is OFF';
  }
  compute();
}

/* ===================== HCS STATE ===================== */
const freshLevees = () => ({ left:{enabled:false, station:null, crest:null}, right:{enabled:false, station:null, crest:null} });
let ineffectiveAreas = [];
let obstructions = [];
let levees = freshLevees();

const cloneHcs = (value) => {
  if (value == null) return value;
  return JSON.parse(JSON.stringify(value));
};

function getHcsState(){
  return {
    ineffectiveAreas: cloneHcs(ineffectiveAreas) || [],
    obstructions: cloneHcs(obstructions) || [],
    levees: cloneHcs(levees) || freshLevees()
  };
}

function setHcsState(hcs){
  const src = hcs || {};
  ineffectiveAreas = Array.isArray(src.ineffectiveAreas) ? cloneHcs(src.ineffectiveAreas) : [];
  obstructions = Array.isArray(src.obstructions) ? cloneHcs(src.obstructions) : [];
  levees = src.levees && typeof src.levees === 'object' ? cloneHcs(src.levees) : freshLevees();
  renderIFATable();
  renderObsTable();
  renderLevTable();
}

window.getHcsState = getHcsState;
window.setHcsState = setHcsState;

function renderIFATable(){
  const tbody=document.querySelector('#ifaTable tbody');
  tbody.innerHTML='';
  ineffectiveAreas.forEach((row,idx)=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="any" class="ifa-l" value="${row.l??''}"></td>
      <td><input type="number" step="any" class="ifa-r" value="${row.r??''}"></td>
      <td><input type="number" step="any" class="ifa-e" value="${row.elev??''}"></td>
      <td style="text-align:center"><input type="checkbox" class="ifa-p" ${row.permanent?'checked':''}></td>
      <td class="actCol" style="text-align:center"><button class="btnDel" title="Delete">Del</button></td>
    `;
    tbody.appendChild(tr);
    tr.querySelector('.ifa-l').addEventListener('input', e=>{ row.l=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ifa-r').addEventListener('input', e=>{ row.r=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ifa-e').addEventListener('input', e=>{ row.elev=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ifa-p').addEventListener('change', e=>{ row.permanent=!!e.target.checked; compute(); });
    tr.querySelector('.btnDel').addEventListener('click', ()=>{ ineffectiveAreas.splice(idx,1); renderIFATable(); compute(); });
  });
}
document.getElementById('addIFA').addEventListener('click', ()=>{
  ineffectiveAreas.push({l:null,r:null,elev:null,permanent:false});
  renderIFATable();
});

function renderObsTable(){
  const tbody=document.querySelector('#obsTable tbody');
  tbody.innerHTML='';
  obstructions.forEach((row,idx)=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="any" class="ob-l" value="${row.l??''}"></td>
      <td><input type="number" step="any" class="ob-r" value="${row.r??''}"></td>
      <td><input type="number" step="any" class="ob-t" value="${row.top??''}"></td>
      <td class="actCol" style="text-align:center"><button class="btnDel" title="Delete">Del</button></td>
    `;
    tbody.appendChild(tr);
    tr.querySelector('.ob-l').addEventListener('input', e=>{ row.l=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ob-r').addEventListener('input', e=>{ row.r=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ob-t').addEventListener('input', e=>{ row.top=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.btnDel').addEventListener('click', ()=>{ obstructions.splice(idx,1); renderObsTable(); compute(); });
  });
}
document.getElementById('addOBS').addEventListener('click', ()=>{
  obstructions.push({l:null,r:null,top:null});
  renderObsTable();
});

function renderLevTable(){
  const tbl=document.getElementById('levTable');
  ['left','right'].forEach(side=>{
    const tr = tbl.querySelector(`tr[data-side="${side}"]`);
    if(!tr) return;
    const en=tr.querySelector('.lev-en');
    const st=tr.querySelector('.lev-sta');
    const cr=tr.querySelector('.lev-crest');
    en.checked = !!levees[side].enabled;
    st.value = levees[side].station ?? '';
    cr.value = levees[side].crest ?? '';
    en.onchange = ()=>{ levees[side].enabled = !!en.checked; compute(); };
    st.oninput = ()=>{ levees[side].station = parseFloatOrNull(st.value); compute(); };
    cr.oninput = ()=>{ levees[side].crest = parseFloatOrNull(cr.value); compute(); };
  });
}

/* Tabs (separate scopes) */
// Settings tabs (Setup, HCS, Designer)
document.querySelectorAll('.s-tab').forEach(tab=>{
  tab.addEventListener('click', ()=>{
    // deactivate all settings tabs and panels
    document.querySelectorAll('.s-tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tabPanel').forEach(p=>p.classList.remove('active'));
    // activate target
    tab.classList.add('active');
    const tgt = document.getElementById('tab-'+tab.dataset.tab);
    if(tgt) tgt.classList.add('active');
    // No preview state change here; Designer panel already manages preview
    compute();
  });
});

// Cross‑Section tabs (XS Data, XS Designer) — (present only if such tabs exist in DOM)
document.querySelectorAll('.xs-tab').forEach(tab=>{
  tab.addEventListener('click', ()=>{
    // deactivate all xs tabs and panels
    document.querySelectorAll('.xs-tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.xsTabPanel').forEach(p=>p.classList.remove('active'));
    // activate target
    tab.classList.add('active');
    const tgtId = (tab.dataset.tab === 'xsdata') ? 'tab-xsdata' : 'tab-designer';
    const tgt = document.getElementById(tgtId);
    if(tgt) tgt.classList.add('active');
    // Preview only when XS Designer is visible
    if(tab.dataset.tab === 'designer'){
      if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    }else{
      window.__designPreview = null;
    }
    compute();
  });
});

/* ===================== DESIGNER INTEGRATION ===================== */
(function(){
  const MAGENTA = '#FF00FF'; // requested exact hex for design preview line

  // --- Runtime CSS for small Designer UI tweaks ---
  const style = document.createElement('style');
  style.textContent = `
    .segSwitch{ display:inline-flex; border:1px solid #cfcfcf; border-radius:999px; overflow:hidden; background:#fff; }
    .segSwitch input{ display:none; }
    .segSwitch label{ padding:6px 10px; cursor:pointer; user-select:none; border-right:1px solid #e6e6e6; white-space:nowrap; font-size:.95rem; }
    .segSwitch label:last-of-type{ border-right:none; }
    .segSwitch input:checked + label{ background:#e9f0ff; color:#0b3d91; }
    .btnDisabled{ opacity:.5; pointer-events:none; }
    .designPreviewTie{ stroke:${MAGENTA}; stroke-width:2.5; stroke-dasharray:6 6; vector-effect:non-scaling-stroke; }
    .designPreviewLine{ stroke:${MAGENTA}; stroke-width:3; fill:none; vector-effect:non-scaling-stroke; }
  `;
  document.head.appendChild(style);

  // --- State exposed on window for convenience/debug ---
  window.__designerMergeMode = 'replace'; // 'replace' | 'merge'
  window.__designPreview = null;         // { dPts:[], left:{x,z}, right:{x,z}, tie:{L:{x,z}|null, R:{x,z}|null} }

  const autoToggleId = 'designerAutoApply';
  const applyBtnId = 'designerApply';

  function nval(id){
    const el = document.getElementById(id);
    if(!el) return null;
    const v = parseFloat(el.value);
    return Number.isFinite(v) ? v : null;
  }
  function bool(id){
    const el = document.getElementById(id);
    return !!(el && el.checked);
  }
  function intval(id, def){
    const el = document.getElementById(id);
    if(!el) return def;
    const v = parseInt(el.value,10);
    return Number.isFinite(v) ? v : def;
  }
  function setDisabled(ids, dis){ ids.forEach(id=>{ const el=document.getElementById(id); if(el) el.disabled = !!dis; }); }

  function setDesignerEnableStates(){
    const nStages = intval('des-numStages', 1);
    const ibOn = bool('des-isInnerBerm');
    const s2 = [
      'des-s2-D2stg','des-s2-Mbanks_2stg','des-s2-Wbench_L','des-s2-Wbench_R',
      'des-s2-Ybench_L','des-s2-Ybench_R'
    ];
    const s3 = [
      'des-s3-D3stg','des-s3-Mbanks_3stg','des-s3-W3rdstage_L','des-s3-W3rdstage_R',
      'des-s3-y3rdStage_L','des-s3-y3rdStage_R'
    ];
    const ib = ['des-ib-WIB','des-ib-DmaxIB'];
    setDisabled(s2, nStages<2);
    setDisabled(s3, nStages<3);
    setDisabled(ib, !ibOn);
  }

  function getDesignerParamsFromUI(){
    return {
      numStages: intval('des-numStages', 1),
      unitSystem: (document.getElementById('units')?.value || 'US'),
      isInnerBerm: bool('des-isInnerBerm'),
      stage1: {
        Width: nval('des-s1-Width'),
        Depth: nval('des-s1-Depth'),
        mbanks: nval('des-s1-mbanks'),
        ybed: nval('des-s1-ybed'),
        thalweg_shift: nval('des-s1-thalweg_shift'),
        Roundness: nval('des-s1-Roundness')
      },
      stage2: {
        D2stg: nval('des-s2-D2stg'),
        Mbanks_2stg: nval('des-s2-Mbanks_2stg'),
        Wbench_L: nval('des-s2-Wbench_L'),
        Wbench_R: nval('des-s2-Wbench_R'),
        Ybench_L: nval('des-s2-Ybench_L'),
        Ybench_R: nval('des-s2-Ybench_R')
      },
      stage3: {
        D3stg: nval('des-s3-D3stg'),
        Mbanks_3stg: nval('des-s3-Mbanks_3stg'),
        W3rdstage_L: nval('des-s3-W3rdstage_L'),
        W3rdstage_R: nval('des-s3-W3rdstage_R'),
        y3rdStage_L: nval('des-s3-y3rdStage_L'),
        y3rdStage_R: nval('des-s3-y3rdStage_R')
      },
      innerBerm: {
        WIB: nval('des-ib-WIB'),
        DmaxIB: nval('des-ib-DmaxIB')
      },
      advanced: {
        Left_BKF_Height_Multiplier: nval('des-adv-Left_BKF_Height_Multiplier'),
        Right_BKF_Height_Multiplier: nval('des-adv-Right_BKF_Height_Multiplier'),
        Left_Mbanks_BKF_Multiplier: nval('des-adv-Left_Mbanks_BKF_Multiplier'),
        Right_Mbanks_BKF_Multiplier: nval('des-adv-Right_Mbanks_BKF_Multiplier'),
        Left_BKF_Bottom_Slope_Multiplier: nval('des-adv-Left_BKF_Bottom_Slope_Multiplier'),
        Right_BKF_Bottom_Slope_Multiplier: nval('des-adv-Right_BKF_Bottom_Slope_Multiplier'),
        X_datum: nval('des-adv-X_datum'),
        Y_datum: nval('des-adv-Y_datum'),
        Tieout_L: nval('des-adv-Tieout_L'),
        Tieout_R: nval('des-adv-Tieout_R')
      }
    };
  }

  function fmt3(x){ return Number.isFinite(+x) ? (+x).toFixed(3) : ''; }

  function applyDesignerRowsToXsTable(rows){
    try{
      if(!Array.isArray(rows) || !rows.length) return;
      const tbody = document.querySelector('#xsTable tbody');
      if(!tbody) return;
      tbody.innerHTML='';
      for(const r of rows){
        const st = (r && typeof r.station!== 'undefined') ? r.station : null;
        const el = (r && typeof r.elevation!== 'undefined') ? r.elevation : null;
        let tag = '';
        if(r && typeof r.name === 'string'){
          if(r.name === 'L5') tag = 'LB';
          else if(r.name === 'R5') tag = 'RB';
        }
        addRow(fmt3(st), fmt3(el), tag, '');
      }
      ensureTrailingBlankRow();
      clearCellSelection();
      compute();
      updateXsLockFromAutoToggle();
    }catch(e){ /* no-op */ }
  }

  function hasCalc(){ return typeof window.calculateCrossSection === 'function'; }

  // ---------- Tie-out helpers ----------
  // Outward direction: Left => decreasing x; Right => increasing x.
  function tieoutIntersection(bedPts, x0, z0, mVal, side){
    if(!Array.isArray(bedPts) || bedPts.length<2) return null;
    if(!Number.isFinite(x0) || !Number.isFinite(z0)) return null;
    if(!Number.isFinite(mVal) || mVal===0) return null;
    const sgn = (mVal>0)? +1 : -1;               // positive => go higher as you move outward; negative => lower outward
    const absM = Math.abs(mVal);
    // dz/dx for the tie-out line
    const mTie = (side==='L') ? (-sgn/absM) : (sgn/absM);

    let best=null; let bestD=Infinity;
    const eps=1e-12;

    for(let i=0;i<bedPts.length-1;i++){
      let a=bedPts[i], b=bedPts[i+1];
      if(a.x>b.x){ const t=a; a=b; b=t; }
      // Only consider outward side
      if(side==='L'){
        if(a.x > x0 + eps) continue; // segment entirely right of x0
      }else{
        if(b.x < x0 - eps) continue; // segment entirely left of x0
      }
      const x1=a.x, z1=a.z, x2=b.x, z2=b.z;
      if(!(x2>x1)) continue;
      const mBed = (z2 - z1) / (x2 - x1);
      const denom = (mBed - mTie);
      if(Math.abs(denom) < 1e-12) continue; // parallel
      const xi = (z0 - z1 + mBed*x1 - mTie*x0) / denom;
      if(xi < x1 - eps || xi > x2 + eps) continue;
      if(side==='L' && xi > x0 + eps) continue;
      if(side==='R' && xi < x0 - eps) continue;
      const d = (side==='L') ? (x0 - xi) : (xi - x0);
      if(d < -eps) continue;
      if(d < bestD){ bestD=d; best={x:xi, z: z0 + mTie*(xi - x0)}; }
    }
    return best;
  }

  // Build preview object kept on window.__designPreview
  function refreshDesignPreview(){
    const designerTab = document.getElementById('tab-designer');
    if(!designerTab || !designerTab.classList.contains('active')){ window.__designPreview = null; return; }
    if(!hasCalc()) { window.__designPreview = null; return; }
    try{
      setDesignerEnableStates();
      const params = getDesignerParamsFromUI();
      const rows = window.calculateCrossSection(params); // 19 points in L9..R9 order (unique & deduped in calc)
      if(!Array.isArray(rows) || rows.length<2){ window.__designPreview = null; return; }

      // Design polyline sorted by station (ascending)
      const dPts = rows.map(r=>({x:+r.station, z:+r.elevation})).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.z)).sort((a,b)=>a.x-b.x);
      if(dPts.length<2){ window.__designPreview = null; return; }

      const dLeft = dPts[0], dRight = dPts[dPts.length-1];

      // Choose tie-out slopes from the stage count
      const mL = params.advanced?.Tieout_L;
      const mR = params.advanced?.Tieout_R;

      const bed = getPointsWithStagesRaw().slice().sort((a,b)=>a.x-b.x).map(p=>({x:p.x,z:p.z}));

      let tieL=null, tieR=null;
      if(window.__designerMergeMode==='merge'){
        if(Number.isFinite(mL)) tieL = tieoutIntersection(bed, dLeft.x,  dLeft.z,  mL, 'L');
        if(Number.isFinite(mR)) tieR = tieoutIntersection(bed, dRight.x, dRight.z, mR, 'R');
      }

      window.__designPreview = { dPts, left: dLeft, right: dRight, tie: { L: tieL, R: tieR } };
    }catch(_){ window.__designPreview = null; }
  }

  function runDesignerApply(){
    if(!hasCalc()){ return; }
    setDesignerEnableStates();
    const params = getDesignerParamsFromUI();
    try{
      const rows = window.calculateCrossSection(params);
      if(!Array.isArray(rows)) return;

      if(window.__designerMergeMode === 'merge'){
        // Merge into existing cross-section using tie-out intersections
        const design = rows.map(r=>({name:r.name, x:+r.station, z:+r.elevation})).sort((a,b)=>a.x-b.x);

        const bedRaw = getPointsWithStagesRaw().slice().sort((a,b)=>a.x-b.x);
        if(bedRaw.length<2){ applyDesignerRowsToXsTable(rows); return; }

        const mL = params.advanced?.Tieout_L;
        const mR = params.advanced?.Tieout_R;

        const dLeft = design[0], dRight = design[design.length-1];

        const tieL = Number.isFinite(mL) ? tieoutIntersection(bedRaw, dLeft.x, dLeft.z, mL, 'L') : null;
        const tieR = Number.isFinite(mR) ? tieoutIntersection(bedRaw, dRight.x, dRight.z, mR, 'R') : null;

        // If either tie is missing, fall back to replace
        if(!tieL || !tieR){ applyDesignerRowsToXsTable(rows); return; }

        const xL = tieL.x, xR = tieR.x;
        const out = [];

        // keep existing left of xL
        for(const p of bedRaw){ if(p.x < xL - 1e-9) out.push({x:p.x, z:p.z, tag:p.tag, n:p.n}); }

        // splice [tieL -> dLeft -> ... -> dRight -> tieR]
        // keep tags only if they were outside splice; interior will be blank
        // add tieL
        out.push({x:+fmt3(xL), z:+fmt3(tieL.z), tag:'', n:NaN});
        // add design polyline
        for(const d of design){
          out.push({x:+fmt3(d.x), z:+fmt3(d.z), tag:(d.name==='L5'?'LB':(d.name==='R5'?'RB':'')), n:NaN});
        }
        // add tieR
        out.push({x:+fmt3(xR), z:+fmt3(tieR.z), tag:'', n:NaN});

        // keep existing right of xR
        for(const p of bedRaw){ if(p.x > xR + 1e-9) out.push({x:p.x, z:p.z, tag:p.tag, n:p.n}); }

        // Write table
        const tbody = document.querySelector('#xsTable tbody');
        tbody.innerHTML = '';
        out.sort((a,b)=>a.x-b.x).forEach(r=>{
          addRow(fmt3(r.x), fmt3(r.z), (r.tag==='LB'||r.tag==='RB')? r.tag:'', Number.isFinite(r.n)?r.n:'');
        });

        // Preserve existing LB/RB if still present; otherwise pick from design L5/R5
        function findTag(rows, tag){ return rows.find(r=>r.tag===tag) || null; }
        const haveLB = !!findTag(out,'LB');
        const haveRB = !!findTag(out,'RB');
        if(!haveLB || !haveRB){
          // set nearest to the design banks if missing
          function setNearestTag(targetX, tag){
            const rows=[...tbody.querySelectorAll('tr')];
            const arr = rows.map(r => {
              const x = parseFloat(r.querySelector('.station')?.value||'NaN');
              return { r, x };
            }).filter(o => Number.isFinite(o.x)).sort((a,b)=>a.x-b.x);
            if(!arr.length || !Number.isFinite(targetX)) return;
            let best=arr[0], bestD = Math.abs(arr[0].x - targetX);
            for(const o of arr){ const d=Math.abs(o.x - targetX); if(d<bestD){ best=o; bestD=d; } }
            const sel = best.r.querySelector('.stagetag');
            if(sel){ sel.value = tag; enforceUniqueStageTag(sel); }
          }
          const dLB = design.find(r=>r.name==='L5');
          const dRB = design.find(r=>r.name==='R5');
          if(!haveLB && dLB) setNearestTag(dLB.x, 'LB');
          if(!haveRB && dRB) setNearestTag(dRB.x, 'RB');
        }

        ensureTrailingBlankRow();
        clearCellSelection();
        compute();
        updateXsLockFromAutoToggle();
      } else {
        // Replace behavior
        applyDesignerRowsToXsTable(rows);
      }
    }catch(err){ /* no-op */ }
  }

  function maybeAuto(){
    const auto = document.getElementById('designerAutoApply');
    if(auto && auto.checked) {
      runDesignerApply();
    } else {
      // not auto: only refresh preview
      refreshDesignPreview();
      compute();
    }
  }

  function syncDesignerApplyButton(){
    const btn = document.getElementById('designerApply');
    const on = !!document.getElementById('designerAutoApply')?.checked;
    if(btn){
      btn.disabled = on;
      btn.classList.toggle('btnDisabled', on);
    }
  }

  // ----- Wire the Designer merge/replace switch in the main layout -----
  function installDesignerBar(){
    const mergeReplace = document.getElementById('mergeReplace');
    const mergeMerge   = document.getElementById('mergeMerge');

    if(mergeMerge && mergeMerge.checked){
      window.__designerMergeMode = 'merge';
    } else if(mergeReplace && mergeReplace.checked){
      window.__designerMergeMode = 'replace';
    }

    if(mergeReplace){
      mergeReplace.addEventListener('change', ()=>{
        if(mergeReplace.checked){
          window.__designerMergeMode = 'replace';
          refreshDesignPreview();
          compute();
        }
      });
    }

    if(mergeMerge){
      mergeMerge.addEventListener('change', ()=>{
        if(mergeMerge.checked){
          window.__designerMergeMode = 'merge';
          refreshDesignPreview();
          compute();
        }
      });
    }
  }

  function wireDesigner(){
    setDesignerEnableStates();

    // Wire Apply + Auto checkbox behavior
    const applyBtn = document.getElementById('designerApply');
    if(applyBtn){
      applyBtn.addEventListener('click', (e)=>{
        flashButton(e.currentTarget);
        runDesignerApply();
      });
    }
    const auto = document.getElementById('designerAutoApply');
    if(auto){
      auto.addEventListener('change', ()=>{
        syncDesignerApplyButton();
        updateXsLockFromAutoToggle();
        maybeAuto();
      });
    }
    syncDesignerApplyButton();

    // Wire inputs inside Designer to refresh preview or auto apply
    const panel = document.getElementById('tab-designer');
    if(panel){
      panel.querySelectorAll('input,select').forEach(el=>{
        if(el.id === 'designerAutoApply') return;
        el.addEventListener('input', ()=>{ setDesignerEnableStates(); refreshDesignPreview(); maybeAuto(); });
        el.addEventListener('change', ()=>{ setDesignerEnableStates(); refreshDesignPreview(); maybeAuto(); });
      });
    }

    // Wire Designer footer controls
    installDesignerBar();

    const hvn = document.getElementById('hvnToggle');
    if(hvn){ hvn.addEventListener('change', updateXsLockFromAutoToggle); }
    updateXsLockFromAutoToggle();

    // Initial preview (Designer tab may already be active)
    refreshDesignPreview();
  }

  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wireDesigner);
  else wireDesigner();

  // Expose for compute() to call before rendering
  window.refreshDesignPreview = refreshDesignPreview;
  window.MAGENTA_DESIGN = MAGENTA;
})();

function updateXsLockFromAutoToggle(){
  const auto = document.getElementById('designerAutoApply');
  const lock = !!(auto && auto.checked);
  const hvnOn = !!document.getElementById('hvnToggle')?.checked;
  const tbody = document.querySelector('#xsTable tbody');
  if(tbody){
    tbody.querySelectorAll('tr').forEach(tr=>{
      const st = tr.querySelector('input.station');
      const el = tr.querySelector('input.elevation');
      const tg = tr.querySelector('select.stagetag');
      const nv = tr.querySelector('input.nval');
      if(st) st.disabled = lock;
      if(el) el.disabled = lock;
      if(tg) tg.disabled = lock;
      if(nv) nv.disabled = !hvnOn;
    });
  }
  const ins = document.getElementById('insertRow');
  const del = document.getElementById('deleteSelected');
  const srt = document.getElementById('sortBtn');
  if(ins) ins.disabled = lock;
  if(del) del.disabled = lock;
  if(srt) srt.disabled = lock;

  // Also disable Apply button when auto is ON
  const applyBtn = document.getElementById('designerApply');
  if(applyBtn){ applyBtn.disabled = lock; applyBtn.classList.toggle('btnDisabled', lock); }
}

/* ===================== GEOMETRY & HYDRAULICS ===================== */
/* (Engine left as in your version; removed here for brevity changes are below where needed) */

function parseFloatOrNull(v){ const x=parseFloat(v); return Number.isFinite(x)?x:null; }

/* HVn helpers */
/* HCS → effective bed and levees */

/* ===================== MAIN COMPUTE ===================== */
function compute(){
  updateSliceOptionStates();
  const nLOB=parseFloat(document.getElementById('nLOB').value);
  const nMC =parseFloat(document.getElementById('nMC').value);
  const nROB=parseFloat(document.getElementById('nROB').value);
  const S   =parseFloat(document.getElementById('slope').value);
  const D   =parseFloat(document.getElementById('depth').value);
  const units=document.getElementById('units').value;
  const plotMode=(document.querySelector('input[name="plotMode"]:checked')||{}).value || 'off';
  const hvnOn = document.getElementById('hvnToggle').checked;
  const useQ = !!document.getElementById('specifyQ').checked;
  const Qtarget = parseFloat(document.getElementById('discharge').value);

  // --- Overlays: Results only (plot stays interactive) ---
  const resShade = document.getElementById('resultsShade');
  const resNote  = document.getElementById('resultsNote');
  const distShade= document.getElementById('distShade');
  const distNote = document.getElementById('distNote');
  const convShade= document.getElementById('convShade');
  const convNote = document.getElementById('convNote');

  // Clear any prior overlays/messages on Results tables
  [resShade, resNote, distShade, distNote, convShade, convNote].forEach(el => {
    if (!el) return;
    el.style.display = 'none';
    // Notes (text containers) get their content cleared
    if (el === resNote || el === distNote || el === convNote) el.textContent = '';
  });
  document.getElementById('summary').classList.remove('disabled');
  document.getElementById('distTable').classList.remove('disabled');
  document.getElementById('convTable').classList.remove('disabled');

  // Show overlays only on Results — never on the cross‑section plot
  function greyOutAll(msg){
    [resShade, resNote, distShade, distNote, convShade, convNote].forEach(el => {
      if (el) el.style.display = 'flex';
    });
    if (resNote)  resNote.textContent  = msg;
    if (distNote) distNote.textContent = msg;
    if (convNote) convNote.textContent = msg;
    document.getElementById('summary').classList.add('disabled');
    document.getElementById('distTable').classList.add('disabled');
    document.getElementById('convTable').classList.add('disabled');
  }
  function greyOutDist(msg){
    if (distShade) distShade.style.display = 'flex';
    if (distNote){
      distNote.style.display = 'flex';
      distNote.textContent = msg;
    }
    document.getElementById('distTable').classList.add('disabled');
  }

  if(!(S>0) || (!useQ && !(D>=0)) || (useQ && !(Qtarget>=0))){
    greyOutAll('Enter positive slope S and ' + (useQ ? 'non‑negative discharge Q.' : 'non‑negative depth D.'));
    // Before we render, refresh the Designer preview so it can draw with the current XS
    if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    renderPlot([], NaN, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  const raw=getPointsWithStagesRaw();
  if(raw.length<2){
    greyOutAll('Not enough data: provide at least two Station–Elevation points, and select LB & RB.');
    if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    renderPlot([], NaN, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  const stations=raw.map(p=>p.x);
  const hasDup=(new Set(stations)).size!==stations.length;
  const isStrictIncreasing=stations.every((v,i,a)=> i===0 || v>a[i-1]);
  const minZ=Math.min(...raw.map(p=>p.z));
  let stage=minZ + (Number.isFinite(D)?D:0);

  if(hasDup){
    greyOutAll('Station values must be unique.');
    if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    renderPlot(raw, stage, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }
  if(!isStrictIncreasing){
    greyOutAll('Stations must increase left→right. Use the “Sort by Station” button.');
    if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    renderPlot(raw, stage, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  const pts=raw;
  const LB=pts.find(p=>p.tag==='LB')||null;
  const RB=pts.find(p=>p.tag==='RB')||null;
  if(!LB || !RB || !(LB.x<RB.x)){
    greyOutAll('Select one LB and one RB (LB must be left of RB).');
    if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    renderPlot(pts, stage, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  // If HVn is ON, validate segments before solving for discharge
  if(hvnOn){
    const rowsSortedCheck = getPointsWithStagesRaw();
    const builtCheck = buildNSegments(rowsSortedCheck);
    if(!builtCheck.ok){
      greyOutAll(builtCheck.err);
      if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
      renderPlot(pts, stage, [], units, { mode:'off' });
      renderDistTable(null, units, 0, 0);
      renderConveyanceTable(null, units, null);
      return;
    }
  }

  // Specify Discharge mode: find stage that meets target Q
  if(useQ){
    const xMinTmp=pts[0].x, xMaxTmp=pts[pts.length-1].x;
    const kConstTmp=(units==='US')?1.486:1.0;
    const sqrtSTmp=Math.sqrt(S);
    let hvnSegs=null, SL=null, SR=null, uniqueNs=null;
    if(hvnOn){
      const rowsSorted = getPointsWithStagesRaw();
      const built = buildNSegments(rowsSorted);
      hvnSegs = built.segments || [];
      const br = bankSlopeRatios(pts, LB.x, RB.x); SL=br.SL; SR=br.SR;
      uniqueNs = Array.from(new Set(hvnSegs.map(s=>s.n).filter(Number.isFinite)));
    }
    function Q_of_stage(stageVal){
      const convBedTmp = buildConveyanceBed(pts, stageVal);
      const clipTmp = leveeClip(stageVal, xMinTmp, xMaxTmp);
      const leftGeomTmp =integrateSectionInRangeOnBed(convBedTmp, stageVal, clipTmp.L, Math.min(LB.x, clipTmp.R));
      const mainGeomTmp =integrateSectionInRangeOnBed(convBedTmp, stageVal, Math.max(LB.x, clipTmp.L), Math.min(RB.x, clipTmp.R));
      const rightGeomTmp=integrateSectionInRangeOnBed(convBedTmp, stageVal, Math.max(RB.x, clipTmp.L), clipTmp.R);
      function partK(geom,n){ const A=geom.A,P=geom.P; const R=(A>0&&P>0)?A/P:0; const AR23=(A>0&&R>0)?A*Math.pow(R,2/3):0; return (AR23>0&&n>0)?(kConstTmp/n)*AR23:0; }
      if(!hvnOn){
        const Ksum = partK(leftGeomTmp,nLOB)+partK(mainGeomTmp,nMC)+partK(rightGeomTmp,nROB);
        return Ksum*sqrtSTmp;
      }else{
        const leftSegs = clipSegments(hvnSegs, clipTmp.L, Math.min(LB.x, clipTmp.R));
        const chSegs   = clipSegments(hvnSegs, Math.max(LB.x, clipTmp.L), Math.min(RB.x, clipTmp.R));
        const rightSegs= clipSegments(hvnSegs, Math.max(RB.x, clipTmp.L), clipTmp.R);
        function KsumFromSegs(segList){ let s=0; for(const seg of segList){ const g=integrateSectionInRangeOnBed(convBedTmp, stageVal, seg.xL, seg.xR); const A=g.A,P=g.P; const R=(A>0&&P>0)?A/P:0; const AR23=(A>0&&R>0)?A*Math.pow(R,2/3):0; const K=(AR23>0&&seg.n>0)?(kConstTmp/seg.n)*AR23:0; s+=K; } return s; }
        const useComposite = (uniqueNs? uniqueNs.length>=2:false) && ((SL??Infinity)<5.0 || (SR??Infinity)<5.0);
        let K_C=0;
        if(useComposite){ let P_C=0, top=0; const A_C=mainGeomTmp.A; for(const seg of chSegs){ const g=integrateSectionInRangeOnBed(convBedTmp, stageVal, seg.xL, seg.xR); P_C+=g.P; top+=g.P*Math.pow(seg.n,1.5);} const n_c=(P_C>0)?Math.pow(top/P_C,2/3):(uniqueNs&&uniqueNs.length?uniqueNs[0]:NaN); const R_C=(P_C>0&&A_C>0)?A_C/P_C:0; const AR23_C=(A_C>0&&R_C>0)?A_C*Math.pow(R_C,2/3):0; K_C=(n_c>0&&AR23_C>0)?(kConstTmp/n_c)*AR23_C:0; }
        else { K_C = KsumFromSegs(chSegs); }
        const Ksum = KsumFromSegs(leftSegs) + K_C + KsumFromSegs(rightSegs);
        return Ksum*sqrtSTmp;
      }
    }
    if(Qtarget<=0 || !Number.isFinite(Qtarget)){
      stage = minZ;
      // Reflect depth even when Q is zero/invalid (at most 2 decimals)
      {
        const dShown = Math.max(0, stage - minZ);
        document.getElementById('depth').value = +dShown.toFixed(2);
      }
    }else{
      let dLo=0, dHi=(Number.isFinite(D)&&D>0)?D:1.0; let qHi=Q_of_stage(minZ+dHi); let n=0;
      while(qHi<Qtarget && dHi<1e6 && n<60){ dHi*=2; qHi=Q_of_stage(minZ+dHi); n++; }
      if(!(qHi>=Qtarget)){
        stage=minZ+dHi;
      }else{
        for(let k=0;k<60;k++){
          const dMid=0.5*(dLo+dHi); const qMid=Q_of_stage(minZ+dMid);
          if(!Number.isFinite(qMid)) break;
          if(Math.abs(qMid-Qtarget) <= Math.max(1e-6, 1e-6*Qtarget)){ dLo=dHi=dMid; break; }
          if(qMid<Qtarget) dLo=dMid; else dHi=dMid;
          if((dHi-dLo)<=1e-6) break;
        }
        stage=minZ+0.5*(dLo+dHi);
      }
      {
        const dShown = Math.max(0, stage - minZ);
        document.getElementById('depth').value = +dShown.toFixed(2); // at most 2 decimals
      }
    }
  }

  const xMin=pts[0].x, xMax=pts[pts.length-1].x;
  const convBed = buildConveyanceBed(pts, stage);
  const clip = leveeClip(stage, xMin, xMax);

  const whole=integrateSectionInRangeOnBed(convBed, stage, clip.L, clip.R);
  const leftGeom =integrateSectionInRangeOnBed(convBed, stage, clip.L, Math.min(LB.x, clip.R));
  const mainGeom =integrateSectionInRangeOnBed(convBed, stage, Math.max(LB.x, clip.L), Math.min(RB.x, clip.R));
  const rightGeom=integrateSectionInRangeOnBed(convBed, stage, Math.max(RB.x, clip.L), clip.R);

  const kConst=(units==='US')?1.486:1.0;
  const g =(units==='US')?32.174:9.80665;
  const sqrtS =Math.sqrt(S);
  const gamma =(units==='US')?62.4:9810;

  let metrics, Qtot, Korig, convReport;

  const eqN_fromPanels = (panels)=>{
    let sumAR=0, denom=0;
    for(const p of panels){
      const R=(p.A>0 && p.P>0)? p.A/p.P : 0;
      const AR23=(p.A>0 && R>0)? p.A*Math.pow(R,2/3) : 0;
      sumAR += AR23;
      denom += (p.n>0 ? AR23/p.n : 0);
    }
    return (sumAR>0 && denom>0)? (sumAR/denom) : NaN;
  };

  if(!hvnOn){
    function partMetrics(geom, nPart){
      const A=geom.A, P=geom.P, T=geom.T;
      const R=(P>0&&A>0)?A/P:0;
      const AR23=(A>0&&R>0)? A*Math.pow(R,2/3):0;
      const K=(AR23>0)?(kConst/nPart)*AR23:0;
      const Q=K*sqrtS;
      const V=(A>0)?Q/A:0;
      const Davg=(T>0)?A/T:0;
      const tau=gamma*R*S;
      const streamPower=tau*V;
      const Fr=(Davg>0)? V/Math.sqrt(g*Davg):0;
      return {A,P,T,R,K,Q,V,Davg,tau,streamPower,Fr,AR23};
    }
    const mLeft =partMetrics(leftGeom, nLOB);
    const mMain =partMetrics(mainGeom, nMC);
    const mRight=partMetrics(rightGeom, nROB);

    const Ktot=mLeft.K + mMain.K + mRight.K;
    Qtot=Ktot*sqrtS;
    const nXS = eqN_fromPanels([
      {A:leftGeom.A, P:leftGeom.P, n:nLOB},
      {A:mainGeom.A, P:mainGeom.P, n:nMC},
      {A:rightGeom.A, P:rightGeom.P, n:nROB}
    ]);
    const Atot=leftGeom.A + mainGeom.A + rightGeom.A;
    const Ptot=leftGeom.P + mainGeom.P + rightGeom.P;
    const Ttot=whole.T;
    const Rtot=(Atot>0&&Ptot>0)? Atot/Ptot:0;
    const Vtot=(Atot>0)? Qtot/Atot:0;
    const DavgTot=(Ttot>0)? Atot/Ttot:0;
    const tauTot=gamma*Rtot*S;
    const streamPowerTot=tauTot*Vtot;
    const FrTot=(DavgTot>0)? Vtot/Math.sqrt(g*DavgTot):0;

    metrics = {
      XS:{Q:Qtot, n:nXS, V:Vtot, P:Ptot, A:Atot, R:Rtot, T:Ttot, D:DavgTot, Dmax:Math.max(stage-Math.min(...pts.map(p=>p.z)),0), tau:tauTot, sp:streamPowerTot, Fr:FrTot},
      MC:{Q:mMain.Q, n:nMC, V:mMain.V, P:mainGeom.P, A:mainGeom.A, R:mMain.R, T:mainGeom.T, D:mMain.Davg, Dmax:Math.max(0, stage - Math.min(mainGeom.wetIntervals.length?Math.min(...polylineBetween(pts,LB.x,RB.x).map(p=>p.z)):stage, stage)), tau:mMain.tau, sp:mMain.streamPower, Fr:mMain.Fr},
      LO:{Q:mLeft.Q, n:nLOB, V:mLeft.V, P:leftGeom.P, A:leftGeom.A, R:mLeft.R, T:leftGeom.T, D:mLeft.Davg, Dmax:Math.max(0, stage - Math.min(leftGeom.wetIntervals.length?Math.min(...polylineBetween(pts,xMin,LB.x).map(p=>p.z)):stage, stage)), tau:mLeft.tau, sp:mLeft.streamPower, Fr:mLeft.Fr},
      RO:{Q:mRight.Q, n:nROB, V:mRight.V, P:rightGeom.P, A:rightGeom.A, R:mRight.R, T:rightGeom.T, D:mRight.Davg, Dmax:Math.max(0, stage - Math.min(rightGeom.wetIntervals.length?Math.min(...polylineBetween(pts,RB.x,xMax).map(p=>p.z)):stage, stage)), tau:mRight.tau, sp:mRight.streamPower, Fr:mRight.Fr}
    };
    Korig = (sqrtS>0)? (Qtot/sqrtS) : 0;
    convReport = null;
  }else{
    const rowsSorted=getPointsWithStagesRaw();
    const built=buildNSegments(rowsSorted);
    if(!built.ok){
      greyOutAll(built.err);
      if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
      renderPlot(pts, stage, [], units, { mode:'off' });
      renderDistTable(null, units, 0, 0);
      renderConveyanceTable(null, units, null);
      return;
    }
    const segs=built.segments;
    const leftSegs = clipSegments(segs, clip.L, Math.min(LB.x, clip.R));
    const rightSegs= clipSegments(segs, Math.max(RB.x, clip.L), clip.R);

    function computePartFromSegments(segList){
      const items=[];
      let sumK=0, sumA=0, sumP=0, sumAR23=0, denom=0;
      for(const s of segList){
        const geom=integrateSectionInRangeOnBed(convBed, stage, s.xL, s.xR);
        const A=geom.A, P=geom.P;
        const R=(A>0&&P>0)? A/P : 0;
        const AR23=(A>0&&R>0)? A*Math.pow(R,2/3):0;
        const K=(AR23>0 && s.n>0)? (kConst/s.n)*AR23 : 0;
        items.push({zone:'', xL:s.xL, xR:s.xR, n:s.n, A, P, R, K, AR23});
        sumK+=K; sumA+=A; sumP+=P; sumAR23+=AR23; denom += (s.n>0? AR23/s.n : 0);
      }
      const Rpart=(sumA>0&&sumP>0)? sumA/sumP : 0;
      return {items, Ksum:sumK, Asum:sumA, Psum:sumP, Rpart, sumAR23, denomAR:denom};
    }

    const chSegs = clipSegments(segs, Math.max(LB.x, clip.L), Math.min(RB.x, clip.R));
    const uniqueNs = Array.from(new Set(chSegs.map(s=>s.n).filter(Number.isFinite)));
    const {SL, SR} = bankSlopeRatios(pts, LB.x, RB.x);
    const useComposite = (uniqueNs.length>=2) && ((SL < 5.0) || (SR < 5.0));

    const leftPart = computePartFromSegments(leftSegs);
    const rightPart = computePartFromSegments(rightSegs);

    let chItems=[], K_C=0, A_C=mainGeom.A, P_C=0, R_C=0, n_c=null, AR23_C=0, denomCH=0;
    if(useComposite){
      const pPieces=[]; for(const s of chSegs){ const g=integrateSectionInRangeOnBed(convBed, stage, s.xL, s.xR); pPieces.push({n:s.n, P:g.P}); }
      P_C = pPieces.reduce((a,b)=>a+b.P,0);
      const top = pPieces.reduce((a,b)=>a + b.P*Math.pow(b.n,1.5), 0);
      n_c = (P_C>0)? Math.pow(top/P_C, 2/3) : uniqueNs[0] || NaN;
      R_C = (P_C>0 && A_C>0)? (A_C/P_C) : 0;
      AR23_C = (A_C>0 && R_C>0)? A_C*Math.pow(R_C,2/3) : 0;
      K_C = (n_c>0 && AR23_C>0)? (kConst/n_c)*AR23_C : 0;
      denomCH = (n_c>0)? AR23_C/n_c : 0;
      chItems.push({zone:'Channel (composite)', xL:Math.max(LB.x, clip.L), xR:Math.min(RB.x, clip.R), n:n_c, A:A_C, P:P_C, R:R_C, K:K_C, AR23:AR23_C});
    }else{
      const chPart = computePartFromSegments(chSegs);
      chItems = chPart.items.map(o=>({zone:'Channel', ...o}));
      K_C = chPart.Ksum; A_C=chPart.Asum; P_C=chPart.Psum; R_C=chPart.Rpart; AR23_C = chPart.sumAR23; denomCH = chPart.denomAR;
    }

    const K_L = leftPart.Ksum, K_R = rightPart.Ksum;
    const K_T = K_L + K_C + K_R;
    Qtot = K_T * sqrtS;
    Korig = (sqrtS>0)? (Qtot/sqrtS) : 0;

    const Atot=leftPart.Asum + A_C + rightPart.Asum;
    const Ptot=leftPart.Psum + P_C + rightPart.Psum;
    const Ttot=whole.T;
    const Rtot=(Atot>0&&Ptot>0)? Atot/Ptot:0;

    const sumAR_LO = leftPart.sumAR23, denomLO = leftPart.denomAR;
    const sumAR_RO = rightPart.sumAR23, denomRO = rightPart.denomAR;
    const sumAR_XS = sumAR_LO + AR23_C + sumAR_RO;
    const denomXS = denomLO + denomCH + denomRO;

    const n_LO = (sumAR_LO>0 && denomLO>0)? sumAR_LO/denomLO : NaN;
    const n_MC = useComposite ? n_c : (AR23_C>0 && denomCH>0 ? AR23_C/denomCH : NaN);
    const n_RO = (sumAR_RO>0 && denomRO>0)? sumAR_RO/denomRO : NaN;
    const n_XS = (sumAR_XS>0 && denomXS>0)? sumAR_XS/denomXS : NaN;

    const Vtot=(Atot>0)? Qtot/Atot:0;
    const DavgTot=(Ttot>0)? Atot/Ttot:0;
    const tauTot=gamma*Rtot*S;
    const streamPowerTot=tauTot*Vtot;
    const FrTot=(DavgTot>0)? Vtot/Math.sqrt(g*DavgTot):0;

    metrics = {
      XS:{Q:Qtot, n:n_XS, V:Vtot, P:Ptot, A:Atot, R:Rtot, T:Ttot, D:DavgTot, Dmax:Math.max(stage-Math.min(...pts.map(p=>p.z)),0), tau:tauTot, sp:streamPowerTot, Fr:FrTot},
      MC:{Q:(K_C*sqrtS), n:n_MC, V:(A_C>0?(K_C*sqrtS)/A_C:0), P:P_C, A:A_C, R:R_C, T:mainGeom.T, D:(Ttot>0?A_C/Ttot:0),
          Dmax:Math.max(0, stage - Math.min(mainGeom.wetIntervals.length?Math.min(...polylineBetween(pts,LB.x,RB.x).map(p=>p.z)):stage, stage)),
          tau:gamma*R_C*S, sp:(gamma*R_C*S)*(A_C>0?(K_C*sqrtS)/A_C:0), Fr:((Ttot>0?A_C/Ttot:0)>0? ((A_C>0?(K_C*sqrtS)/A_C:0) / Math.sqrt(g*(A_C/Ttot)) ):0)},
      LO:{Q:(K_L*sqrtS), n:n_LO, V:(leftPart.Asum>0?(K_L*sqrtS)/leftPart.Asum:0), P:leftPart.Psum, A:leftPart.Asum, R:leftPart.Rpart, T:leftGeom.T, D:(Ttot>0?leftPart.Asum/Ttot:0),
          Dmax:Math.max(0, stage - Math.min(leftGeom.wetIntervals.length?Math.min(...polylineBetween(pts,xMin,LB.x).map(p=>p.z)):stage, stage)),
          tau:gamma*leftPart.Rpart*S, sp:(gamma*leftPart.Rpart*S)*(leftPart.Asum>0?(K_L*sqrtS)/leftPart.Asum:0), Fr:((Ttot>0?leftPart.Asum/Ttot:0)>0? ((leftPart.Asum>0?(K_L*sqrtS)/leftPart.Asum:0) / Math.sqrt(g*(leftPart.Asum/Ttot)) ):0)},
      RO:{Q:(K_R*sqrtS), n:n_RO, V:(rightPart.Asum>0?(K_R*sqrtS)/rightPart.Asum:0), P:rightPart.Psum, A:rightPart.Asum, R:rightPart.Rpart, T:rightGeom.T, D:(Ttot>0?rightPart.Asum/Ttot:0),
          Dmax:Math.max(0, stage - Math.min(rightGeom.wetIntervals.length?Math.min(...polylineBetween(pts,RB.x,xMax).map(p=>p.z)):stage, stage)),
          tau:gamma*rightPart.Rpart*S, sp:(gamma*rightPart.Rpart*S)*(rightPart.Asum>0?(K_R*sqrtS)/rightPart.Asum:0), Fr:((Ttot>0?rightPart.Asum/Ttot:0)>0? ((rightPart.Asum>0?(K_R*sqrtS)/rightPart.Asum:0) / Math.sqrt(g*(rightPart.Asum/Ttot)) ):0)}
    };
    convReport = {
      K_L, K_C, K_R, K_T, Q:Qtot,
      parts: {
        left: leftPart.items.map(o=>({zone:'Left OB', ...o})),
        channel: chItems,
        right: rightPart.items.map(o=>({zone:'Right OB', ...o}))
      }
    };
  }

  renderSummary(metrics, units);
  // When using depth mode, reflect computed total Q in the Discharge input (rounded to 0.1)
  try{
    if(!useQ && metrics && metrics.XS && Number.isFinite(metrics.XS.Q)){
      const qEl=document.getElementById('discharge');
      qEl.value = +metrics.XS.Q.toFixed(1); // at most 1 decimal
    }
  }catch(_){/* noop */}

  let dist=null;
  const Ntotal=(parseInt(document.getElementById('N_LOB').value,10)||1) + (parseInt(document.getElementById('N_CHAN').value,10)||1) + (parseInt(document.getElementById('N_ROB').value,10)||1);
  if(Ntotal>45){
    greyOutDist(`Total slices (${Ntotal}) exceed cap of 45. Reduce LOB/Channel/ROB counts to ≤ 45 for HEC‑RAS parity.`);
    renderDistTable(null, units, 0, 0);
  }else{
    dist=computeDistribution(
      convBed, stage,
      {left:leftGeom, main:mainGeom, right:rightGeom},
      { nLOB:(hvnOn?NaN:nLOB), nMC:(hvnOn?NaN:nMC), nROB:(hvnOn?NaN:nROB) },
      { S, kConst, gamma, sqrtS },
      { N_LOB: parseInt(document.getElementById('N_LOB').value,10)||1,
        N_CH: parseInt(document.getElementById('N_CHAN').value,10)||1,
        N_ROB: parseInt(document.getElementById('N_ROB').value,10)||1 },
      metrics.XS.Q
    );
    renderDistTable(dist, units, metrics.XS.Q, (sqrtS>0?metrics.XS.Q/sqrtS:0));
  }

  renderConveyanceTable(hvnOn?convReport:null, units, null);

  // n-segments for plot
  let nSegments = [];
  if (hvnOn) {
    const rowsSorted2 = getPointsWithStagesRaw();
    nSegments = buildPlotNSegmentsFromExplicit(rowsSorted2, pts[0].x, pts[pts.length-1].x);
  } else {
    nSegments = [
      {xL: pts[0].x, xR: LB.x, n: nLOB},
      {xL: LB.x, xR: RB.x, n: nMC },
      {xL: RB.x, xR: pts[pts.length-1].x, n: nROB}
    ];
  }

  const bedForPlot = pts;

  // ---- NEW: Update Designer preview before drawing plot so it renders on top ----
  if (typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();

  let wetIntervals = integrateSectionInRangeOnBed(pts, stage, clip.L, clip.R).wetIntervals;
  renderPlot(bedForPlot, stage, wetIntervals, units, {
    mode: plotMode,
    dist,
    xsAvg:{V:metrics.XS.V, tau:metrics.XS.tau},
    nSegments,
    hcs: { ineffectiveAreas, obstructions, levees, clip }
  });
}



/* Summary / Conveyance / Dist tables */
function renderSummary(data, units){
  const lenU=units==='US'?'ft':'m';
  const areaU=units==='US'?'ft²':'m²';
  const velU=units==='US'?'ft/s':'m/s';
  const qU =units==='US'?'cfs':'m³/s';
  const tauU=units==='US'?'lb/ft²':'Pa';
  const spU =units==='US'?'lb/(ft·s)':'N/(m·s)';

  const rows=[
    ['Discharge', m=>fmt(m.Q), qU],
    ['n (used)', m=>Number.isFinite(m.n)? m.n.toFixed(3) : '—', ''],
    ['Velocity Avg', m=>fmt(m.V), velU],
    ['Wetted Perimeter', m=>fmt(m.P), lenU],
    ['Area', m=>fmt(m.A), areaU],
    ['Hydraulic Radius R', m=>fmt(m.R), lenU],
    ['Top Width', m=>fmt(m.T), lenU],
    ['Depth avg', m=>fmt(m.D), lenU],
    ['Depth max', m=>fmt(m.Dmax), lenU],
    ['Shear Stress avg', m=>fmt(m.tau),tauU],
    ['Unit Stream Power', m=>fmt(m.sp), spU],
    ['Froude', m=>fmt(m.Fr), '']
  ];

  const cols=[ ['XS Average','XS'], ['Main Channel','MC'], ['Left Overbank','LO'], ['Right Overbank','RO'] ];

  let html='<thead><tr><th>Metric</th>';
  for(const [label] of cols) html+=`<th>${label}</th>`;
  html+='</tr></thead><tbody>';
  for(const [label,get,unit] of rows){
    const withUnit = unit ? `${label} (${unit})` : label;
    html+=`<tr><th>${withUnit}</th>`;
    for (const [,key] of cols) html+=`<td>${get(data[key])}</td>`;
    html+='</tr>';
  }
  html+='</tbody>';
  document.getElementById('summary').innerHTML=html;
}

function renderConveyanceTable(report, units, phys){
  const tbl=document.getElementById('convTable');
  const shade=document.getElementById('convShade');
  const note=document.getElementById('convNote');
  shade.style.display='none'; note.style.display='none';
  if(!report){
    tbl.innerHTML = `
      <thead><tr>
        <th>Zone</th><th>Left Sta</th><th>Right Sta</th><th>n</th><th>A</th><th>P</th><th>R</th><th>K</th>
      </tr></thead>
      <tbody><tr><td colspan="8">Horizontal variation of n is OFF.</td></tr></tbody>
    `;
    return;
  }
  const lenU=units==='US'?'ft':'m';
  const areaU=units==='US'?'ft²':'m²';
  const kUnit = units==='US' ? 'cfs/√S' : 'm³/s/√S';

  function row(o){
    return `<tr>
      <td>${o.zone||''}</td>
      <td>${fmt(o.xL)}</td>
      <td>${fmt(o.xR)}</td>
      <td>${Number.isFinite(o.n)? o.n.toFixed(3) : '—'}</td>
      <td>${fmt(o.A)}</td>
      <td>${fmt(o.P)}</td>
      <td>${fmt(o.R)}</td>
      <td>${fmt(o.K)}</td>
    </tr>`;
  }

  let html = `<thead><tr>
    <th>Zone</th>
    <th>Left Sta (${lenU})</th>
    <th>Right Sta (${lenU})</th>
    <th>n</th>
    <th>A (${areaU})</th>
    <th>P (${lenU})</th>
    <th>R (${lenU})</th>
    <th>K (${kUnit})</th>
  </tr></thead><tbody>`;

  for(const o of report.parts.left) html+=row(o);
  for(const o of report.parts.channel)html+=row(o);
  for(const o of report.parts.right) html+=row(o);

  html+=`</tbody><tfoot><tr>
    <td colspan="8"><strong>K<sub>L</sub>=${fmt(report.K_L)}, K<sub>C</sub>=${fmt(report.K_C)}, K<sub>R</sub>=${fmt(report.K_R)}, K<sub>total</sub>=${fmt(report.K_T)}, Q=${fmt(report.Q)}</strong></td>
  </tr></tfoot>`;
  tbl.innerHTML = html;
}

function renderDistTable(dist, units, Qtot, Korig){
  const tbl=document.getElementById('distTable');
  const lenU=units==='US'?'ft':'m';
  const areaU=units==='US'?'ft²':'m²';
  const velU=units==='US'?'ft/s':'m/s';
  const qU =units==='US'?'cfs':'m³/s';
  const tauU=units==='US'?'lb/ft²':'Pa';
  const powU=units==='US'?'lb/(ft·s)':'N/(m·s)';

  let html= `<thead><tr>
    <th>Pos</th>
    <th>Left Sta (${lenU})</th>
    <th>Right Sta (${lenU})</th>
    <th>Flow (${qU})</th>
    <th>Area (${areaU})</th>
    <th>W.P. (${lenU})</th>
    <th>Percent Conv (%)</th>
    <th>Hydr Depth (${lenU})</th>
    <th>Velocity (${velU})</th>
    <th>Shear (${tauU})</th>
    <th>Power (${powU})</th>
  </tr></thead><tbody>`;

  let sumQ=0, sumPct=0;
  if(dist && dist.slices && dist.slices.length){
    for(const s of dist.slices){
      html+= `<tr>
        <td>${s.label}</td>
        <td>${fmt(s.sL)}</td>
        <td>${fmt(s.sR)}</td>
        <td>${fmt(s.Q)}</td>
        <td>${fmt(s.A)}</td>
        <td>${fmt(s.P)}</td>
        <td>${fmt(s.pctK)}</td>
        <td>${fmt(s.Dh)}</td>
        <td>${fmt(s.V)}</td>
        <td>${fmt(s.tau)}</td>
        <td>${fmt(s.Power)}</td>
      </tr>`;
      sumQ+=s.Q; sumPct+=s.pctK;
    }
  }
  html+=`</tbody><tfoot><tr>
    <td>Totals</td><td></td><td></td>
    <td>${fmt(sumQ)}</td><td></td><td></td>
    <td>${fmt(sumPct)}</td><td></td><td></td><td></td><td></td>
  </tr></tfoot>`;
  tbl.innerHTML=html;
}

/* ===================== PLOT ===================== */
/* NEW: global to expose plot transform for click mapping */
let _plotState = null;

function renderPlot(pts, stage, wetIntervals = [], units, opts){
  const svg=document.getElementById('plot');
  svg.innerHTML='';
  const W=svg.viewBox.baseVal.width||1000, H=svg.viewBox.baseVal.height||360;
  if(!pts || pts.length<2) return;

  const defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.appendChild(defs);

  const M={left:116,right:170,top:46,bottom:72};
  const innerW=Math.max(10, W - M.left - M.right);
  const innerH=Math.max(10, H - M.top - M.bottom);

  const xs=pts.map(p=>p.x), zs=pts.map(p=>p.z);
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const padX=(maxX-minX)*0.08 || 1;
  const x0=minX-padX, x1=maxX+padX;

  const maxBed=Math.max(...zs), minBed=Math.min(...zs);
  const maxTarget = Number.isFinite(stage) ? Math.max(maxBed, stage) : maxBed;

  // Publish plot state for click mapping (used by Bank Tools)
  _plotState = { W, H, M, innerW, innerH, x0, x1, svg };

  const probe=niceTicks(minBed, maxTarget, 6);
  let yStep=(probe.length>=2)?(probe[1]-probe[0]):((maxTarget-minBed)||1);
  if(!(yStep>0)) yStep=0.5;
  const z0=Math.floor(minBed/yStep)*yStep;
  const z1=(Math.floor(maxTarget+yStep*0.01)/yStep+1)*yStep;
  const yTicksOverride=ticksFromStep(z0, z1, yStep);

  const sx=x=> M.left + ((x - x0)/(x1 - x0))*innerW;
  const sy=z=> M.top + (1 - (z - z0)/(z1 - z0))*innerH;

  drawAxes(svg,x0,x1,z0,z1,sx,sy,units,M,W,H,yTicksOverride);

  // n labels strip near the top
  const yN = sy(z1) - 15;
  const cap = 8;

  function drawSpan(a,b,val){
    if(!(b>a)) return;
    const xL=sx(a), xR=sx(b), xMid=(xL+xR)/2;

    // main horizontal n line
    const hLine=document.createElementNS('http://www.w3.org/2000/svg','line');
    hLine.setAttribute('x1',xL); hLine.setAttribute('y1',yN);
    hLine.setAttribute('x2',xR); hLine.setAttribute('y2',yN);
    hLine.setAttribute('stroke','#444');
    hLine.setAttribute('stroke-width','2');                 
    svg.appendChild(hLine);

    // end caps (thick)
    const c1=document.createElementNS('http://www.w3.org/2000/svg','line');
    c1.setAttribute('x1',xL); c1.setAttribute('y1',yN - cap/2);
    c1.setAttribute('x2',xL); c1.setAttribute('y2',yN + cap/2);
    c1.setAttribute('stroke','#444');
    c1.setAttribute('stroke-width','2');                    
    svg.appendChild(c1);

    const c2=document.createElementNS('http://www.w3.org/2000/svg','line');
    c2.setAttribute('x1',xR); c2.setAttribute('y1',yN - cap/2);
    c2.setAttribute('x2',xR); c2.setAttribute('y2',yN + cap/2);
    c2.setAttribute('stroke','#444');
    c2.setAttribute('stroke-width','2');                    
    svg.appendChild(c2);

    // label
    const label = (+val).toFixed(6).replace(/\.?0+$/, '').replace(/^0\./,'.');
    const txt=document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x',xMid); txt.setAttribute('y',yN);
    txt.setAttribute('text-anchor','middle'); txt.setAttribute('dominant-baseline','middle');
    txt.setAttribute('class','nlabel'); txt.textContent=label;
    svg.appendChild(txt);

    // white background for label
    const bb=txt.getBBox(); const pad=3.5;
    const bg=document.createElementNS('http://www.w3.org/2000/svg','rect');
    bg.setAttribute('x', bb.x - pad); bg.setAttribute('y', bb.y - pad);
    bg.setAttribute('width', bb.width + 2*pad); bg.setAttribute('height', bb.height + 2*pad);
    bg.setAttribute('fill','#fff'); bg.setAttribute('rx','4'); bg.setAttribute('ry','4');
    svg.insertBefore(bg, txt);
  }

  if (opts && Array.isArray(opts.nSegments) && opts.nSegments.length){
    for (const seg of opts.nSegments) {
      if (Number.isFinite(seg.n)) drawSpan(seg.xL, seg.xR, seg.n);
    }
  }

  // Water fill
  if (Number.isFinite(stage) && wetIntervals && wetIntervals.length){
    for(const [a,b] of wetIntervals){
      const seg=polylineBetween(pts, a, b);
      if(seg.length>=2){
        const d=['M', sx(a), sy(stage), 'L'];
        seg.forEach((p,i)=>{ d.push(i?',':'', sx(p.x), sy(p.z)); });
        d.push('L', sx(b), sy(stage), 'Z');
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', d.join(' '));
        path.setAttribute('fill','#4da3ff'); path.setAttribute('opacity','0.28'); path.setAttribute('stroke','none');
        svg.appendChild(path);
      }
    }
  }

  // Obstructions fill
  if (opts?.hcs?.obstructions?.length){
    for(const ob of opts.hcs.obstructions){
      if(!ob || !Number.isFinite(ob.l) || !Number.isFinite(ob.r) || !Number.isFinite(ob.top)) continue;
      const xl=Math.min(ob.l,ob.r), xr=Math.max(ob.l,ob.r);
      const seg=polylineBetween(pts, xl, xr);
      if(seg.length>=2){
        const d=['M', sx(xl), sy(ob.top)];
        seg.forEach((p,i)=>{ d.push(i?',':'','L', sx(p.x), sy(Math.min(p.z, ob.top))); });
        d.push('L', sx(xr), sy(ob.top), 'Z');
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', d.join(' '));
        path.setAttribute('fill', '#555'); path.setAttribute('opacity','0.9'); path.setAttribute('stroke','none');
        svg.appendChild(path);
      }
    }
  }

  // IFA hatching
  if (opts?.hcs?.ineffectiveAreas?.length){
    let ifaIndex = 0;
    for(const ia of opts.hcs.ineffectiveAreas){
      if(!ia || !Number.isFinite(ia.l) || !Number.isFinite(ia.r) || !Number.isFinite(ia.elev)) continue;
      const xl=Math.min(ia.l, ia.r), xr=Math.max(ia.l, ia.r);
      const topZ = Math.min(stage, ia.elev);
      const seg=polylineBetween(pts, xl, xr);
      if(seg.length>=2){
        const d=['M', sx(xl), sy(topZ)];
        seg.forEach((p,i)=>{ const z = Math.min(p.z, topZ); d.push(i?',':'','L', sx(p.x), sy(z)); });
        d.push('L', sx(xr), sy(topZ), 'Z');
        const polyPath = d.join(' ');

        const clipId = `ifaClip_${ifaIndex++}`;
        const cp=document.createElementNS('http://www.w3.org/2000/svg','clipPath');
        cp.setAttribute('id', clipId); cp.setAttribute('clipPathUnits','userSpaceOnUse');
        const cpPath=document.createElementNS('http://www.w3.org/2000/svg','path'); cpPath.setAttribute('d', polyPath);
        cp.appendChild(cpPath); defs.appendChild(cp);

        const stripesG=document.createElementNS('http://www.w3.org/2000/svg','g');
        stripesG.setAttribute('clip-path', `url(#${clipId})`);
        const cx = M.left + innerW/2; const cy = M.top + innerH/2;
        const rotG=document.createElementNS('http://www.w3.org/2000/svg','g');
        rotG.setAttribute('transform', `rotate(-45 ${cx} ${cy})`);
        const green = getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#2e7d32';
        const spacing = 10; const margin = W + H;
        const xStart = M.left - margin; const xEnd = M.left + innerW + margin;
        const yMin = M.top - margin; const yMax = M.top + innerH + margin;
        for(let y = yMin; y <= yMax; y += spacing){
          const ln=document.createElementNS('http://www.w3.org/2000/svg','line');
          ln.setAttribute('x1', xStart); ln.setAttribute('y1', y);
          ln.setAttribute('x2', xEnd); ln.setAttribute('y2', y);
          ln.setAttribute('stroke', green);
          ln.setAttribute('stroke-width', '2');
          ln.setAttribute('stroke-linecap', 'square');
          rotG.appendChild(ln);
        }
        stripesG.appendChild(rotG);
        svg.appendChild(stripesG);
      }
    }
  }

  // Bed line + points
  const bedPath=pts.map((p,i)=>(i?'L':'M')+sx(p.x)+','+sy(p.z)).join(' ');
  const bed=document.createElementNS('http://www.w3.org/2000/svg','path');
  bed.setAttribute('d',bedPath); bed.setAttribute('fill','none');
  bed.setAttribute('stroke','#222'); bed.setAttribute('stroke-width','2');
  svg.appendChild(bed);
  for(const p of pts){
    const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx',sx(p.x)); c.setAttribute('cy',sy(p.z));
    c.setAttribute('r',(p.tag==='LB'||p.tag==='RB')?6.5:5.8);
    c.setAttribute('class',(p.tag==='LB'||p.tag==='RB')?'point bank':'point');
    svg.appendChild(c);
  }
  if(Number.isFinite(stage)){
    const line=document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',M.left); line.setAttribute('y1',sy(stage));
    line.setAttribute('x2',M.left+innerW); line.setAttribute('y2',sy(stage));
    line.setAttribute('stroke','#1e88e5'); line.setAttribute('stroke-dasharray','6 6');
    svg.appendChild(line);
  }

  // Levees + IFA guides
  if (opts?.hcs?.levees) {
    const magenta = getComputedStyle(document.documentElement).getPropertyValue('--magenta').trim() || '#c2185b';
    const zAtX = (x) => {
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i], b = pts[i + 1];
        if (x >= a.x && x <= b.x && b.x !== a.x) {
          const t = (x - a.x) / (b.x - a.x);
          return a.z + t * (b.z - a.z);
        }
      }
      return null;
    };
    const drawOne = (lev) => {
      if (!lev || !lev.enabled) return;
      if (!Number.isFinite(lev.station) || !Number.isFinite(lev.crest)) return;
      const xMin = pts[0].x, xMax = pts[pts.length - 1].x;
      if (lev.station < xMin || lev.station > xMax) return;
      const zBed = zAtX(lev.station); if (!Number.isFinite(zBed)) return;
      if (lev.crest <= zBed) return;
      const x = sx(lev.station); const yBed = sy(zBed); const yCrest = sy(lev.crest);
      const v = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      v.setAttribute('x1', x); v.setAttribute('y1', yBed);
      v.setAttribute('x2', x); v.setAttribute('y2', yCrest);
      v.setAttribute('stroke', magenta); v.setAttribute('stroke-width', '3');
      v.setAttribute('vector-effect', 'non-scaling-stroke'); svg.appendChild(v);
      const sz = 12; const cap = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      cap.setAttribute('x', x - sz / 2); cap.setAttribute('y', yCrest - sz / 2);
      cap.setAttribute('width', sz); cap.setAttribute('height', sz);
      cap.setAttribute('fill', 'none'); cap.setAttribute('stroke', magenta); cap.setAttribute('stroke-width', '2.5');
      cap.setAttribute('vector-effect', 'non-scaling-stroke'); svg.appendChild(cap);
    };
    drawOne(opts.hcs.levees.left); drawOne(opts.hcs.levees.right);
  }

  if (opts?.hcs?.ineffectiveAreas?.length){
    const green = getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#2e7d32';
    for(const ia of opts.hcs.ineffectiveAreas){
      if(!ia || !Number.isFinite(ia.l) || !Number.isFinite(ia.r) || !Number.isFinite(ia.elev)) continue;
      const xl=Math.min(ia.l, ia.r), xr=Math.max(ia.l, ia.r);
      const seg=polylineBetween(pts, xl, xr);
      if(seg.length>=2){
        const zL = seg.length? seg[0].z : null;
        const zR = seg.length? seg[seg.length-1].z : null;
        const v1=document.createElementNS('http://www.w3.org/2000/svg','line');
        v1.setAttribute('x1', sx(xl)); v1.setAttribute('x2', sx(xl));
        v1.setAttribute('y1', sy(Math.min(zL, ia.elev))); v1.setAttribute('y2', sy(ia.elev));
        v1.setAttribute('stroke', green); v1.setAttribute('stroke-width','2'); svg.appendChild(v1);

        const v2=document.createElementNS('http://www.w3.org/2000/svg','line');
        v2.setAttribute('x1', sx(xr)); v2.setAttribute('x2', sx(xr));
        v2.setAttribute('y1', sy(Math.min(zR, ia.elev))); v2.setAttribute('y2', sy(ia.elev));
        v2.setAttribute('stroke', green); v2.setAttribute('stroke-width','2'); svg.appendChild(v2);

        function tri(xc,yc){
          const p=document.createElementNS('http://www.w3.org/2000/svg','path');
          const s=8;
          const d=`M ${xc} ${yc-5} l ${-s/2} ${s} h ${s} z`;
          p.setAttribute('d', d); p.setAttribute('fill', green); return p;
        }
        svg.appendChild(tri(sx(xl), sy(ia.elev)));
        svg.appendChild(tri(sx(xr), sy(ia.elev)));

        const h=document.createElementNS('http://www.w3.org/2000/svg','line');
        h.setAttribute('x1', sx(xl)); h.setAttribute('x2', sx(xr));
        h.setAttribute('y1', sy(ia.elev)); h.setAttribute('y2', sy(ia.elev));
        h.setAttribute('stroke', green); h.setAttribute('stroke-width','2');
        svg.appendChild(h);
      }
    }
  }

  // ---- NEW: Designer preview overlay (only visible on Designer tab) ----
  (function drawDesignOverlay(){
    const designerTab = document.getElementById('tab-designer');
    if(!designerTab || !designerTab.classList.contains('active')) return;
    const prev = window.__designPreview;
    if(!prev || !Array.isArray(prev.dPts) || prev.dPts.length<2) return;

    const MAGENTA = window.MAGENTA_DESIGN || '#FF00FF';

    // Design line
    const dPath = prev.dPts.map((p,i)=>(i?'L':'M') + sx(p.x) + ',' + sy(p.z)).join(' ');
    const pth = document.createElementNS('http://www.w3.org/2000/svg','path');
    pth.setAttribute('d', dPath);
    pth.setAttribute('stroke', MAGENTA);
    pth.setAttribute('class', 'designPreviewLine');
    svg.appendChild(pth);

    // Tie-outs only when merge mode is ON
    if(window.__designerMergeMode === 'merge'){
      if(prev.tie?.L){
        const L = document.createElementNS('http://www.w3.org/2000/svg','line');
        L.setAttribute('x1', sx(prev.tie.L.x)); L.setAttribute('y1', sy(prev.tie.L.z));
        L.setAttribute('x2', sx(prev.left.x));  L.setAttribute('y2', sy(prev.left.z));
        L.setAttribute('class', 'designPreviewTie');
        svg.appendChild(L);
      }
      if(prev.tie?.R){
        const R = document.createElementNS('http://www.w3.org/2000/svg','line');
        R.setAttribute('x1', sx(prev.right.x)); R.setAttribute('y1', sy(prev.right.z));
        R.setAttribute('x2', sx(prev.tie.R.x)); R.setAttribute('y2', sy(prev.tie.R.z));
        R.setAttribute('class', 'designPreviewTie');
        svg.appendChild(R);
      }
    }
  })();

  const mode=(opts&&opts.mode)||'off';
  const xPlotRight=M.left+innerW;
  const TAU_AXIS_OFFSET = 84;

  if(mode==='slices' && opts?.dist?.slices?.length){
    const velMaxRaw=Math.max(...opts.dist.slices.map(s=>s.V),0);
    const tauMaxRaw=Math.max(...opts.dist.slices.map(s=>s.tau),0);
    const velTop=niceCeil(velMaxRaw);
    const tauUp =niceCeilPlusOneTick(tauMaxRaw);
    const tauTop=tauUp.top;
    const tauTicks=ticksFromStep(0, tauTop, tauUp.step);

    const yV=v=> M.top + (1 - (v/(velTop||1))) * innerH;
    const yT=t=> M.top + (1 - (t/(tauTop||1))) * innerH;

    const uniq=Array.from(new Set(opts.dist.boundaries.map(v=>+v.toFixed(12)))).sort((a,b)=>a-b);
    uniq.forEach(x=>{
      const l=document.createElementNS('http://www.w3.org/2000/svg','line');
      l.setAttribute('x1',sx(x)); l.setAttribute('y1',M.top);
      l.setAttribute('x2',sx(x)); l.setAttribute('y2',M.top+innerH);
      l.setAttribute('class','slice-boundary'); svg.appendChild(l);
    });

    const velPath=[], tauPath=[];
    for(const s of opts.dist.slices){
      const yyV=yV(s.V), yyT=yT(s.tau);
      const xL=sx(s.sL), xR=sx(s.sR);
      velPath.push(velPath.length?'L':'M', xL, yyV, 'L', xR, yyV);
      tauPath.push(tauPath.length?'L':'M', xL, yyT, 'L', xR, yyT);
    }
    const p1=document.createElementNS('http://www.w3.org/2000/svg','path');
    p1.setAttribute('d',velPath.join(' ')); p1.setAttribute('class','prof-vel'); svg.appendChild(p1);
    const p2=document.createElementNS('http://www.w3.org/2000/svg','path');
    p2.setAttribute('d',tauPath.join(' ')); p2.setAttribute('class','prof-tau'); svg.appendChild(p2);

    const xAxisVel=xPlotRight;
    const xAxisTau=xPlotRight + TAU_AXIS_OFFSET;
    drawSecondaryAxis(svg,xAxisVel,M.top,innerH,0,velTop, units==='US'?'ft/s':'m/s', true, '#b71c1c','Velocity', null);
    drawSecondaryAxis(svg,xAxisTau,M.top,innerH,0,tauTop, units==='US'?'lb/ft²':'Pa', true, '#6f42c1','Shear', tauTicks);
  } else if(mode==='xs' && opts?.xsAvg){
    const V=Math.max(0,+opts.xsAvg.V||0);
    const T=Math.max(0,+opts.xsAvg.tau||0);
    const velTop=niceCeil(V);
    const tauTop=niceCeil(T);
    const yV=v=> M.top + (1 - (v/(velTop||1))) * innerH;
    const yT=t=> M.top + (1 - (t/(tauTop||1))) * innerH;
    if(wetIntervals && wetIntervals.length){
      for(const [a,b] of wetIntervals){
        const vLine=document.createElementNS('http://www.w3.org/2000/svg','line');
        vLine.setAttribute('x1',sx(a)); vLine.setAttribute('x2',sx(b));
        vLine.setAttribute('y1',yV(V));  vLine.setAttribute('y2',yV(V));
        vLine.setAttribute('class','prof-vel'); svg.appendChild(vLine);

        const tLine=document.createElementNS('http://www.w3.org/2000/svg','line');
        tLine.setAttribute('x1',sx(a)); tLine.setAttribute('x2',sx(b));
        tLine.setAttribute('y1',yT(T));  tLine.setAttribute('y2',yT(T));
        tLine.setAttribute('class','prof-tau'); svg.appendChild(tLine);
      }
    }
    const xAxisVel=xPlotRight;
    const xAxisTau=xPlotRight + TAU_AXIS_OFFSET;
    drawSecondaryAxis(svg,xAxisVel,M.top,innerH,0,velTop, units==='US'?'ft/s':'m/s', true, '#b71c1c','Velocity', null);
    drawSecondaryAxis(svg,xAxisTau,M.top,innerH,0,tauTop, units==='US'?'lb/ft²':'Pa', true, '#6f42c1','Shear', null);
  }
}

function drawSecondaryAxis(svg,xAxis,yTop,h,vMin,vMax,unitLabel,labelsRight,color,title,tickList){
  const ax=document.createElementNS('http://www.w3.org/2000/svg','line');
  ax.setAttribute('x1',xAxis); ax.setAttribute('y1',yTop);
  ax.setAttribute('x2',xAxis); ax.setAttribute('y2',yTop+h);
  ax.setAttribute('class','secondary-axis');
  svg.appendChild(ax);

  const tickLen=7, labelPad=8, titlePad=56;
  const ticks=(tickList && tickList.length)? tickList : niceTicksSafe(vMin,vMax,5);
  const denom=(vMax-vMin);
  const mapY=v=> yTop + (1 - ((v - vMin)/(denom || 1)) )*h;

  ticks.forEach(v=>{
    const y=mapY(v);
    const t=document.createElementNS('http://www.w3.org/2000/svg','line');
    t.setAttribute('x1',xAxis); t.setAttribute('y1',y);
    t.setAttribute('x2',xAxis + (labelsRight? tickLen : -tickLen)); t.setAttribute('y2',y);
    t.setAttribute('class','secondary-tick'); t.setAttribute('style', `stroke:${color}`);
    svg.appendChild(t);

    const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
    const xLbl=xAxis + (labelsRight? (tickLen + labelPad) : (-tickLen - labelPad));
    lbl.setAttribute('x',xLbl); lbl.setAttribute('y',y+5);
    lbl.setAttribute('class','secondary-label');
    lbl.setAttribute('text-anchor', labelsRight ? 'start':'end');
    lbl.setAttribute('style', `fill:${color}`);
    lbl.textContent=fmtTick(v);
    svg.appendChild(lbl);
  });

  const titleEl=document.createElementNS('http://www.w3.org/2000/svg','text');
  const xLab=xAxis + (labelsRight? (tickLen + titlePad) : (-tickLen - titlePad));
  const yLab=yTop + h/2;
  titleEl.setAttribute('x',xLab); titleEl.setAttribute('y',yLab);
  titleEl.setAttribute('class','secondary-label'); titleEl.setAttribute('text-anchor','middle');
  titleEl.setAttribute('transform',`rotate(-90 ${xLab} ${yLab})`);
  titleEl.setAttribute('style', `fill:${color}`);
  titleEl.textContent=`${title} (${unitLabel})`;
  svg.appendChild(titleEl);
}

function drawAxes(svg,x0,x1,z0,z1,sx,sy,units,M,W,H,yTicksOverride=null){
  const xAxisY=M.top + (H - M.top - M.bottom);
  const yAxisX=M.left;
  const axis=(x1v,y1v,x2v,y2v,cls='axis')=>{
    const l=document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',x1v); l.setAttribute('y1',y1v);
    l.setAttribute('x2',x2v); l.setAttribute('y2',y2v);
    l.setAttribute('class',cls); svg.appendChild(l);
  };
  axis(M.left, xAxisY, M.left + (W - M.left - M.right), xAxisY);
  axis(yAxisX, M.top, yAxisX, M.top + (H - M.top - M.bottom));

  const eps=1e-9, approxEq=(a,b)=> Math.abs(a-b) <= (Math.max(1,Math.abs(a),Math.abs(b))*1e-9);
  let xticks=niceTicksSafe(x0,x1,6).filter(v=>v>=x0-eps && v<=x1+eps);
  if(!xticks.length || !approxEq(xticks[0],x0)) xticks.unshift(x0);
  let yticks=(Array.isArray(yTicksOverride) && yTicksOverride.length)? yTicksOverride.slice() : niceTicksSafe(z0,z1,6);
  yticks=yticks.filter(v=>v>=z0-eps && v<=z1+eps);
  if(!yticks.length || !approxEq(yticks[0],z0)) yticks.unshift(z0);

  const tickLen=12;
  xticks.forEach(v=>{
    const x=sx(v);
    axis(x, xAxisY, x, xAxisY + tickLen, 'tick-mark');
    axis(M.left, xAxisY, M.left + (W - M.left - M.right), xAxisY, 'grid');
    axis(M.left, M.top, M.left + (W - M.left - M.right), M.top, 'grid');
    if(!approxEq(v,x0)){
      const lblY=Math.min(H-6, xAxisY + tickLen + 18);
      const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.setAttribute('x',x); lbl.setAttribute('y',lblY);
      lbl.setAttribute('class','tick-label'); lbl.setAttribute('text-anchor','middle');
      lbl.textContent=fmtTick(v); svg.appendChild(lbl);
    }
  });
  yticks.forEach(v=>{
    const y=sy(v);
    axis(yAxisX - tickLen, y, yAxisX, y, 'tick-mark');
    axis(M.left, y, M.left + (W - M.left - M.right), y, 'grid');
    if(!approxEq(v,z0)){
      const lblX=Math.max(6, yAxisX - tickLen - 10);
      const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.setAttribute('x',lblX); lbl.setAttribute('y',y+5);
      lbl.setAttribute('class','tick-label'); lbl.setAttribute('text-anchor','end');
      lbl.textContent=fmtTick(v); svg.appendChild(lbl);
    }
  });

  const lenU=units==='US'?'ft':'m';
  const xMid=M.left + (W - M.left - M.right)/2;
  const xlab=document.createElementNS('http://www.w3.org/2000/svg','text');
  xlab.setAttribute('x',xMid);
  xlab.setAttribute('y', Math.min(H-8, xAxisY + tickLen + 38));
  xlab.setAttribute('class','axis-label'); xlab.setAttribute('text-anchor','middle');
  xlab.textContent=`Station (${lenU})`; svg.appendChild(xlab);

  const yMid=M.top + (H - M.top - M.bottom)/2;
  const ylabX=Math.max(12, yAxisX - tickLen - 56);
  const ylab=document.createElementNS('http://www.w3.org/2000/svg','text');
  ylab.setAttribute('x',ylabX); ylab.setAttribute('y',yMid);
  ylab.setAttribute('class','axis-label'); ylab.setAttribute('text-anchor','middle');
  ylab.setAttribute('transform',`rotate(-90 ${ylabX} ${yMid})`);
  ylab.textContent=`Elevation (${lenU})`; svg.appendChild(ylab);
}

function niceTicks(min,max,count){
  const span=max-min;
  if(!(span>0)) return [min,max];
  const step=Math.pow(10, Math.floor(Math.log10(span/Math.max(1,count-1))));
  const err=(span/(count-1))/step;
  const mult=(err>=7.5)?10:(err>=3)?5:(err>=1.5)?2:1;
  const niceStep=mult*step;
  const niceMin=Math.floor(min/niceStep)*niceStep;
  const niceMax=Math.ceil(max/niceStep)*niceStep;
  const ticks=[];
  for(let v=niceMin; v<=niceMax+1e-12; v+=niceStep) ticks.push(+v.toFixed(12));
  return ticks.length?ticks:[min,max];
}
function niceTicksSafe(min,max,count){
  const t=niceTicks(min,max,count);
  if(t.length<2){ return [min,max>min?max:min+1]; }
  return t;
}
function niceCeil(maxVal){
  const base=(maxVal>0?maxVal:1);
  const t=niceTicks(0,base,5);
  return t[t.length-1]||base;
}
function niceCeilPlusOneTick(maxVal){
  const base=(maxVal>0?maxVal:1);
  const t=niceTicks(0,base,5);
  let step=(t.length>=2)?(t[1]-t[0]):(base||1);
  if(!(step>0)) step=1;
  const top=(t[t.length-1]||0)+step;
  return {top,step};
}
function ticksFromStep(min,max,step){
  if(!(step>0)) step=1;
  const out=[]; for(let v=min; v<=max+1e-12; v+=step) out.push(+v.toFixed(12));
  return out;
}
function fmt(x){
  if(!Number.isFinite(x)) return '—';
  const ax=Math.abs(x);
  const d=(ax>=1000)?0:(ax>=100)?1:(ax>=10)?2:3;
  return x.toFixed(d);
}
function fmtTick(x){
  const ax=Math.abs(x);
  const d=(ax>=1000)?0:(ax>=100)?0:(ax>=10)?1:2;
  return x.toFixed(d);
}

/* Help modal */
const helpModal=document.getElementById('helpModal'),
      openHelp=document.getElementById('openHelp'),
      closeHelp=document.getElementById('closeHelp');
openHelp.addEventListener('click',(e)=>{ flashButton(e.currentTarget); helpModal.style.display='flex'; document.body.classList.add('modal-open'); });
closeHelp.addEventListener('click',()=>{ helpModal.style.display='none'; document.body.classList.remove('modal-open'); });
helpModal.addEventListener('click',(e)=>{ if(e.target===helpModal){ helpModal.style.display='none'; document.body.classList.remove('modal-open'); }});

/* ===================== n Picker ===================== */
const nPickerModal=document.getElementById('nPickerModal');
const openNPicker=document.getElementById('openNPicker');
const closeNPicker=document.getElementById('closeNPicker');
const applyN=document.getElementById('applyN');
const applyCloseN=document.getElementById('applyCloseN');
const nCurVal=document.getElementById('nCurVal');
const nMinus=document.getElementById('nMinus');
const nPlus=document.getElementById('nPlus');
const nSearch=document.getElementById('nSearch');
const nCardGrid=document.getElementById('nCardGrid');
const nPickerMsg=document.getElementById('nPickerMsg');

let nPickerState = { seg: 'chan', anchor: 'typ', choiceId: null, value: 0.035 };

openNPicker.addEventListener('click', (e)=>{
  flashButton(e.currentTarget);
  renderNCards(); syncNPickerFromInputs();
  nPickerModal.style.display='flex'; document.body.classList.add('modal-open');
  if(document.getElementById('hvnToggle').checked){
    nPickerMsg.textContent='Note: HVn is ON — LOB/Channel/ROB n values will not affect results until HVn is OFF.';
  }else{ nPickerMsg.textContent=''; }
});
closeNPicker.addEventListener('click', ()=>{ nPickerModal.style.display='none'; document.body.classList.remove('modal-open'); });

document.querySelectorAll('#nPickerModal .chips button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('#nPickerModal .chips button').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active'); nPickerState.seg = btn.dataset.seg; syncNPickerFromInputs();
  });
});
document.querySelectorAll('#nPickerModal .preset').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('#nPickerModal .preset').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active'); nPickerState.anchor = btn.dataset.a;
    if(nPickerState.choiceId){
      const rec=N_CATALOG.find(r=>r.id===nPickerState.choiceId);
      if(rec){ const v=anchorToVal(rec.n, nPickerState.anchor); nPickerState.value=v; updateNVal(); }
    }
  });
});
nMinus.addEventListener('click', ()=>{ nPickerState.value = +(nPickerState.value - 0.001).toFixed(3); updateNVal(); });
nPlus.addEventListener('click', ()=>{ nPickerState.value = +(nPickerState.value + 0.001).toFixed(3); updateNVal(); });
nSearch.addEventListener('input', renderNCards);
applyN.addEventListener('click', (e)=>{ flashButton(e.currentTarget); applyNToInputs(); });
applyCloseN.addEventListener('click', (e)=>{ flashButton(e.currentTarget); applyNToInputs(); nPickerModal.style.display='none'; document.body.classList.remove('modal-open'); });

function syncNPickerFromInputs(){
  const v = nPickerState.seg==='lob' ? parseFloat(document.getElementById('nLOB').value)
        : nPickerState.seg==='rob' ? parseFloat(document.getElementById('nROB').value)
        : parseFloat(document.getElementById('nMC').value);
  nPickerState.value = Number.isFinite(v)? v : 0.035;
  nCurVal.textContent = nPickerState.value.toFixed(3);
}
function applyNToInputs(){
  const v = nPickerState.value.toFixed(3);
  if(nPickerState.seg==='lob') document.getElementById('nLOB').value = v;
  else if(nPickerState.seg==='rob') document.getElementById('nROB').value = v;
  else document.getElementById('nMC').value = v;
  compute();
}
function updateNVal(){ nCurVal.textContent = (+nPickerState.value).toFixed(3); }
function anchorToVal(nObj, a){ if(a==='min' && Number.isFinite(nObj.min)) return nObj.min; if(a==='max' && Number.isFinite(nObj.max)) return nObj.max; return nObj.typ; }

function renderNCards(){
  const query = nSearch.value.trim().toLowerCase();
  const groupsOrder=['Main Channels','Mountain Streams','Floodplains','Excavated or Dredged Channels','Lined or Constructed Channels'];
  const grouped = new Map(); for(const g of groupsOrder) grouped.set(g, []);
  N_CATALOG.forEach(r=>{
    if(query){
      const hay=(r.grp+' '+r.label).toLowerCase();
      if(!hay.includes(query)) return;
    }
    if(!grouped.has(r.grp)) grouped.set(r.grp, []);
    grouped.get(r.grp).push(r);
  });

  let html='';
  for(const g of groupsOrder){
    const arr=grouped.get(g)||[]; if(!arr.length) continue;
    html+=`<div class="grp"><h4>${g}</h4><div class="cards">`;
    for(const r of arr){
      const active = (nPickerState.choiceId===r.id) ? 'active' : '';
      const rng = `${Number.isFinite(r.n.min)?r.n.min.toFixed(3):'—'}–${Number.isFinite(r.n.max)?r.n.max.toFixed(3):'—'}`;
      html+= `<button class="cardBtn ${active}" data-id="${r.id}">
        <div class="lbl">${r.label}</div>
        <div class="rng">Range ${rng} • Typical ${r.n.typ.toFixed(3)}</div>
      </button>`;
    }
    html+='</div></div>';
  }

  nCardGrid.innerHTML=html;
  nCardGrid.querySelectorAll('.cardBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      nCardGrid.querySelectorAll('.cardBtn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const id=btn.getAttribute('data-id');
      nPickerState.choiceId=id;
      const rec=N_CATALOG.find(r=>r.id===id);
      if(rec){
        const v=anchorToVal(rec.n, nPickerState.anchor);
        nPickerState.value=v; updateNVal();
      }
    });
  });
}

/* Reset example */
function resetExample(){
  document.getElementById('units').value = 'US';
  document.getElementById('slope').value = '0.001';
  document.getElementById('nLOB').value = '0.100';
  document.getElementById('nMC').value = '0.035';
  document.getElementById('nROB').value = '0.100';
  document.getElementById('depth').value = 2.5;
  document.getElementById('discharge').value = 0;
  const qToggle = document.getElementById('specifyQ'); qToggle.checked = false; updateQModeUI(false);
  document.getElementById('N_LOB').value = '1';
  document.getElementById('N_CHAN').value = '1';
  document.getElementById('N_ROB').value = '1';

  const pmOff=document.getElementById('pmOff');
  const pmXS=document.getElementById('pmXS');
  const pmSlices=document.getElementById('pmSlices');
  pmOff.checked=true; pmXS.checked=false; pmSlices.checked=false;

  const hvn=document.getElementById('hvnToggle'); hvn.checked=false; updateHVnUI(false);

  ineffectiveAreas = []; obstructions = [];
  levees = freshLevees();
  renderIFATable(); renderObsTable(); renderLevTable();

  tableBody.innerHTML = '';
  const sample = [
    [-40, 3, '', ''],
    [-10, 2, 'LB', ''],
    [-5.5,0.5, '', ''],
    [ 0, 0, '', ''],
    [ 5.5,0.5, '', ''],
    [ 10, 2, 'RB', ''],
    [ 40, 3, '', '']
  ];
  for (const [x,z,t,nv] of sample) addRow(x, z, t, nv);
  ensureTrailingBlankRow();
  clearCellSelection();
  updateSliceOptionStates();
  // Refresh preview as the geometry changed
  if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
  compute();
}
/* ===================== INIT ===================== */
function init(){
  fillSliceSelect(document.getElementById('N_LOB'),1);
  fillSliceSelect(document.getElementById('N_CHAN'),1);
  fillSliceSelect(document.getElementById('N_ROB'),1);
  renderIFATable(); renderObsTable(); renderLevTable();
  resetExample();
  ensureTrailingBlankRow();
  updateSliceOptionStates();
  harmonizeButtons();
}
init();

/* ===================== USGS 3DEP MODAL INTEGRATION ===================== */
(function wireUsgsImport(){
  const openBtn = document.getElementById('open3DEP');
  const modal = document.getElementById('usgsModal');
  const frame = document.getElementById('usgsFrame');

  function openModal(){
    frame.src = 'usgs.html?embedded=1';
    modal.style.display = 'flex';
    document.body.classList.add('modal-open');
  }
  function closeModal(){
    modal.style.display = 'none';
    document.body.classList.remove('modal-open');
    try{ frame.src = 'about:blank'; }catch(_){}
  }

  function unitsLabel(){ return (document.getElementById('units')?.value || 'US'); }
  function mToFt(x){ return x * 3.280839895013123; }
  function ftToM(x){ return x * 0.3048; }
  function round3(x){ return Number.isFinite(+x) ? (+x).toFixed(3) : ''; }

  function applySamples(samples, srcUnits){
    if(!Array.isArray(samples) || !samples.length) return;
    const want = unitsLabel();
    const fromFeet = (srcUnits === 'feet');
    const fromMeters = !fromFeet;
    const convert = (v)=>{
      if(want==='US' && fromMeters) return mToFt(v);
      if(want==='SI' && fromFeet ) return ftToM(v);
      return v;
    };
    const tbody = document.querySelector('#xsTable tbody');
    if(!tbody) return;
    tbody.innerHTML = '';
    let n=0;
    for(const s of samples){
      const st = Number(s.station), el = Number(s.elevation);
      if(!Number.isFinite(st) || !Number.isFinite(el)) continue;
      addRow(round3(convert(st)), round3(convert(el)), '', '');
      n++;
    }
    ensureTrailingBlankRow();
    renumberIDs();
    clearCellSelection();
    // Geometry changed -> preview changes
    if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    compute();
    const msgEl = document.getElementById('messages');
    if(msgEl) msgEl.textContent = `Imported ${n} point(s) from USGS 3DEP. Mark LB and RB to compute.`;
  }

  if(openBtn){
    openBtn.addEventListener('click', (e)=>{
      flashButton(e.currentTarget);
      const auto = document.getElementById('designerAutoApply');
      if(auto && auto.checked){
        alert('Turn off "Automatically Apply" in the Designer tab before importing data from 3DEP.');
        return;
      }
      openModal();
    });
  }
  if(modal){
    modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });
  }
  window.addEventListener('message', (evt)=>{
    const srcWin = frame?.contentWindow;
    if(!srcWin || evt.source !== srcWin) return;
    const data = evt.data || {};
    if(data.type === 'usgs-import'){
      const rows = Array.isArray(data.samples) ? data.samples : [];
      const units = (data.units === 'feet') ? 'feet' : 'meters';
      applySamples(rows, units);
      closeModal();
    }else if(data.type === 'usgs-close-request'){
      closeModal();
    }
  });
})();

/* ===================== Filter modal wiring (filter.html) ===================== */
(function wireFilterModal(){
  const openBtn = document.getElementById('openFilter2');
  const modal = document.getElementById('filterModal');
  const frame = document.getElementById('filterFrame');

  function openModal(){
    frame.src = 'filter.html?embedded=1';
    modal.style.display = 'flex';
    document.body.classList.add('modal-open');
  }
  function closeModal(){
    modal.style.display = 'none';
    document.body.classList.remove('modal-open');
    try{ frame.src = 'about:blank'; }catch(_){ }
  }

  function sendXsToFilter(){
    const ptsRaw = getPointsWithStagesRaw(); // [{x,z,tag,n}]
    const pts = ptsRaw.map(p => ({ x:Number(p.x), z:Number(p.z) }));
    const LB = ptsRaw.find(p => p.tag==='LB') || null;
    const RB = ptsRaw.find(p => p.tag==='RB') || null;
    const units = document.getElementById('units')?.value || 'US';
    try{
      frame.contentWindow.postMessage({
        type:'filter-xs-data',
        payload:{
          points: pts,
          LBStation: LB ? LB.x : null,
          RBStation: RB ? RB.x : null,
          units
        }
      }, '*');
    }catch(_){ }
  }

  if(openBtn){
    openBtn.addEventListener('click', (e)=>{
      flashButton(e.currentTarget);
      const auto = document.getElementById('designerAutoApply');
      if(auto && auto.checked){
        alert('Turn off "Automatically Apply" in the Designer tab before filtering.');
        return;
      }
      openModal();
    });
  }

  if(modal){
    modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });
  }

  window.addEventListener('message', (evt)=>{
    if(!frame || evt.source !== frame.contentWindow) return;
    const data = evt.data || {};
    if(data.type === 'filter-ready'){
      sendXsToFilter();
    }else if(data.type === 'filter-apply'){
      const pl = data.payload || {};
      const pts = Array.isArray(pl.points) ? pl.points : [];
      const LBx = Number.isFinite(pl.LBStation) ? pl.LBStation : null;
      const RBx = Number.isFinite(pl.RBStation) ? pl.RBStation : null;
      applyFilteredXs(pts, LBx, RBx);
      closeModal();
    }else if(data.type === 'filter-close-request' || data.type === 'filter-cancel'){
      closeModal();
    }
  });

  function fmt3(x){ return Number.isFinite(+x) ? (+x).toFixed(3) : ''; }
  function applyFilteredXs(points, LBx, RBx){
    if(!Array.isArray(points) || points.length<2) return;
    const tbody = document.querySelector('#xsTable tbody');
    tbody.innerHTML = '';
    for(const p of points){
      const x = Number(p.x), z = Number(p.z);
      if(Number.isFinite(x) && Number.isFinite(z)) addRow(fmt3(x), fmt3(z), '', '');
    }
    function setNearestTag(targetX, tag){
      if(!Number.isFinite(targetX)) return;
      const rows=[...tbody.querySelectorAll('tr')];
      if(!rows.length) return;
      const arr = rows.map(r => {
        const x = parseFloat(r.querySelector('.station')?.value||'NaN');
        return { r, x };
      }).filter(o => Number.isFinite(o.x)).sort((a,b)=>a.x-b.x);
      if(!arr.length) return;
      let best=arr[0], bestD = Math.abs(arr[0].x - targetX);
      for(const o of arr){ const d=Math.abs(o.x - targetX); if(d<bestD){ best=o; bestD=d; } }
      const sel = best.r.querySelector('.stagetag');
      if(sel){ sel.value = tag; enforceUniqueStageTag(sel); }
    }
    setNearestTag(LBx, 'LB');
    setNearestTag(RBx, 'RB');

    ensureTrailingBlankRow();
    renumberIDs();
    clearCellSelection();
    // Geometry changed -> preview changes
    if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
    compute();
  }
})();

/* ===================== NEW: Bank Tools (LB/RB) ========================= */
(function bankTools(){
  const btnLB = document.getElementById('setLB');
  const btnRB = document.getElementById('setRB');
  const lbLeft = document.getElementById('lbLeft');
  const lbRight = document.getElementById('lbRight');
  const rbLeft = document.getElementById('rbLeft');
  const rbRight = document.getElementById('rbRight');
  const svg = document.getElementById('plot');

  let mode = null; // 'LB' | 'RB' | null

  function setMode(m){
    mode = (mode===m) ? null : m;
    const onLB = (mode==='LB'), onRB = (mode==='RB');
    btnLB && btnLB.classList.toggle('active', onLB);
    btnRB && btnRB.classList.toggle('active', onRB);
    if(btnLB) btnLB.setAttribute('aria-pressed', onLB ? 'true' : 'false');
    if(btnRB) btnRB.setAttribute('aria-pressed', onRB ? 'true' : 'false');
  }

  if(btnLB) btnLB.addEventListener('click', ()=> setMode('LB'));
  if(btnRB) btnRB.addEventListener('click', ()=> setMode('RB'));

  // Helpers over current numeric rows (sorted by station)
  function getRowsSorted(){
    const rows = [...document.querySelectorAll('#xsTable tbody tr')];
    const arr = rows.map(r => {
      const x = parseFloat(r.querySelector('.station')?.value||'NaN');
      const z = parseFloat(r.querySelector('.elevation')?.value||'NaN');
      const tag = r.querySelector('.stagetag')?.value || '';
      return Number.isFinite(x)&&Number.isFinite(z) ? {r,x,z,tag} : null;
    }).filter(Boolean).sort((a,b)=>a.x-b.x);
    return arr;
  }
  function findTagRow(tag){
    const rows = [...document.querySelectorAll('#xsTable tbody tr')];
    for(const r of rows){
      const v = r.querySelector('.stagetag')?.value || '';
      if(v===tag) return r;
    }
    return null;
  }
  function indexOfTag(tag){
    const arr = getRowsSorted();
    const r = findTagRow(tag);
    if(!r) return -1;
    const x = parseFloat(r.querySelector('.station')?.value||'NaN');
    return arr.findIndex(o => Math.abs(o.x - x) < 1e-12);
  }
  function clampLBIndex(iNew){
    const arr = getRowsSorted();
    const idxRB = indexOfTag('RB');
    if(idxRB>=0) iNew = Math.min(iNew, idxRB-1);
    return Math.max(0, Math.min(arr.length-1, iNew));
  }
  function clampRBIndex(iNew){
    const arr = getRowsSorted();
    const idxLB = indexOfTag('LB');
    if(idxLB>=0) iNew = Math.max(iNew, idxLB+1);
    return Math.max(0, Math.min(arr.length-1, iNew));
  }
  function setTagAtIndex(tag, idx){
    const arr = getRowsSorted();
    if(!(idx>=0 && idx<arr.length)) return;
    const sel = arr[idx].r.querySelector('.stagetag');
    if(sel){
      sel.value = tag;
      enforceUniqueStageTag(sel);
      // Geometry not changed, but banks changed -> recompute & preview
      if(typeof window.refreshDesignPreview === 'function') window.refreshDesignPreview();
      compute();
    }
  }

  // Move functions
  function moveBank(tag, dir){
    const arr = getRowsSorted();
    if(!arr.length) return;
    let idx = indexOfTag(tag);
    if(idx < 0){
      // Initialize if missing: LB->leftmost, RB->rightmost
      idx = (tag==='LB') ? 0 : (arr.length-1);
    }
    let iNew = idx + (dir<0 ? -1 : +1);
    iNew = (tag==='LB') ? clampLBIndex(iNew) : clampRBIndex(iNew);
    if(iNew!==idx) setTagAtIndex(tag, iNew);
  }

  if(lbLeft)  lbLeft.addEventListener('click',  (e)=>{ flashButton(e.currentTarget); moveBank('LB', -1); });
  if(lbRight) lbRight.addEventListener('click', (e)=>{ flashButton(e.currentTarget); moveBank('LB', +1); });
  if(rbLeft)  rbLeft.addEventListener('click',  (e)=>{ flashButton(e.currentTarget); moveBank('RB', -1); });
  if(rbRight) rbRight.addEventListener('click', (e)=>{ flashButton(e.currentTarget); moveBank('RB', +1); });

  // Click on plot to set LB/RB to nearest station
  function viewboxXFromClient(evt){
    if(!_plotState || !_plotState.svg) return null;
    const rect = _plotState.svg.getBoundingClientRect();
    const px = evt.clientX - rect.left;
    const scaleX = (_plotState.W || 1000) / rect.width;
    return px * scaleX;
  }
  function stationFromClient(evt){
    if(!_plotState) return null;
    const vx = viewboxXFromClient(evt);
    if(vx==null) return null;
    const { M, innerW, x0, x1 } = _plotState;
    if(!(innerW>0)) return null;
    const t = (vx - M.left) / innerW;
    const s = x0 + t * (x1 - x0);
    return s;
  }
  function setBankAtClick(evt, tag){
    const sClick = stationFromClient(evt);
    if(sClick==null) return;
    const arr = getRowsSorted();
    if(!arr.length) return;

    let idxRB = indexOfTag('RB');
    let idxLB = indexOfTag('LB');

    // choose nearest candidate with LB<RB constraint
    let best = -1, bestD = Infinity;
    for(let i=0;i<arr.length;i++){
      const x = arr[i].x;
      if(tag==='LB' && idxRB>=0 && i>=idxRB) continue;
      if(tag==='RB' && idxLB>=0 && i<=idxLB) continue;
      const d = Math.abs(x - sClick);
      if(d<bestD){ best=i; bestD=d; }
    }
    // If none (because of constraints), clamp to valid boundary
    if(best<0){
      if(tag==='LB'){
        best = (idxRB>=0) ? Math.max(0, idxRB-1) : 0;
      } else {
        best = (idxLB>=0) ? Math.min(arr.length-1, idxLB+1) : (arr.length-1);
      }
    }
    setTagAtIndex(tag, best);
  }

  if(svg){
    svg.addEventListener('click', (evt)=>{
      if(mode==='LB'){ setBankAtClick(evt, 'LB'); setMode(null); }
      else if(mode==='RB'){ setBankAtClick(evt, 'RB'); setMode(null); }
    });
  }
})();

/* ===== Notes =====
 - Designer preview and tie-outs use polylineBetween(), integrateSectionInRangeOnBed(), etc., from app.core.js. Keep that file loaded first.
 - The 19-point Designer geometry is produced by calculateCrossSection(params) from the Designer calculator.
 - This script assumes the same element IDs and overall layout provided in index.html.
*/
